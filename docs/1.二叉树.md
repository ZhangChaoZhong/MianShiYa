---
title: 1.äºŒå‰æ ‘
date: 2021-1-2 22:00:00
tags: Algorithm
categories: ç®—æ³•
---

# 1.äºŒå‰æ ‘

> äºŒå‰æ ‘ï¼š

<!--more-->

### éå†ç³»åˆ—

#### äºŒå‰æ ‘éå†ï¼šè¿­ä»£ç»Ÿä¸€ç‰ˆæœ¬

**ä¸­åº**

```C++
//æ ˆï¼šè®¿é—®é€†åº
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // å°†è¯¥èŠ‚ç‚¹å¼¹å‡ºï¼Œé¿å…é‡å¤æ“ä½œï¼Œä¸‹é¢å†å°†å³ä¸­å·¦èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­
                if (node->right) st.push(node->right);  // æ·»åŠ å³èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰

                st.push(node); // æ·»åŠ æ ¹èŠ‚ç‚¹
                st.push(NULL); // æ ¹èŠ‚ç‚¹è®¿é—®è¿‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºèŠ‚ç‚¹åšä¸ºæ ‡è®°ã€‚

                if (node->left) st.push(node->left);    // æ·»åŠ å·¦èŠ‚ç‚¹ï¼ˆç©ºèŠ‚ç‚¹ä¸å…¥æ ˆï¼‰
            } else { // åªæœ‰é‡åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ï¼Œæ‰å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
                st.pop();           // å°†ç©ºèŠ‚ç‚¹å¼¹å‡º
                node = st.top();    // é‡æ–°å–å‡ºæ ˆä¸­å…ƒç´ 
                st.pop();
                result.push_back(node->val); // åŠ å…¥åˆ°ç»“æœé›†
            }
        }
        return result;
    }
};

```

**ä¸­åº**

```C++
st.pop(); 
if (node->right) st.push(node->right);  
st.push(node); 
st.push(NULL); 
if (node->left) st.push(node->left);   
```

**å‰åº**

```C++
st.pop(); 
if (node->right) st.push(node->right);  
if (node->left) st.push(node->left);   
st.push(node); 
st.push(NULL); 
```

**ååº**

```C++
st.pop(); 
st.push(node); 
st.push(NULL); 
if (node->right) st.push(node->left);  
if (node->left) st.push(node->right);   
```

#### [144. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) â­ï¸

```C++
/*å‰ï¼Œä¸­ï¼Œåï¼Œä¸»è¦çœ‹æ ¹åœ¨å“ªã€‚
æ ¹å·¦å³
âš ï¸ï¼šå½“ç„¶æœ‰äº›å¯èƒ½æ˜¯æ ¹å³å·¦
*/
class Solution {
public:
    void NLR(TreeNode *root, vector<int> &res) {
        if(root == nullptr) return;
        res.push_back(root->val);
        NLR(root->left,res);
        NLR(root->right,res);
    }

    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        NLR(root,res);
        return res;
    }
};
```

#### [94. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```C++
/*
å·¦æ ¹å³
*/
class Solution {
public:
    void LNR(TreeNode *root,vector<int> &res){
        if(root == nullptr) return;
        LNR(root->left,res);
        res.push_back(root->val);
        LNR(root->right,res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        LNR(root,res);
        return res;
    }
};
```

#### [145. äºŒå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```C++
/*
å·¦å³æ ¹
*/
class Solution {
public:
    void LRN(TreeNode *root,vector<int> &res){
        if(root == nullptr) return;
        LRN(root->left,res);
        LRN(root->right,res);
        res.push_back(root->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        LRN(root,res);
        return res;
    }
};
```

#### [173. äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

```C++
/*
BSTç”¨ä¸­åºéå†
*/
class BSTIterator {
public:
    vector<int> res;
    int index=0;
    void LNR(TreeNode *root,vector<int> &res){
        if(root == nullptr) return;
        LNR(root->left,res);
        res.push_back(root->val);
        LNR(root->right,res);
    }
    BSTIterator(TreeNode* root) {
         LNR(root,res);
    }
    int next() {
        return res[index++];
    }
    bool hasNext() {
        return index >= res.size() ? false:true;
    }
};
```

#### [102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) â­ï¸

```C++
/*
æ ‘çš„å±‚åºéå†--å¹¿åº¦ä¼˜å…ˆæœç´¢
æ€è·¯ï¼š
    é¦–å…ˆæ ¹å…ƒç´ å…¥é˜Ÿ
    å½“é˜Ÿåˆ—ä¸ä¸ºç©ºçš„æ—¶å€™
        æ±‚å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ si
        ä¾æ¬¡ä»é˜Ÿåˆ—ä¸­å– siä¸ªå…ƒç´ è¿›è¡Œæ‹“å±•ï¼Œç„¶åè¿›å…¥ä¸‹ä¸€æ¬¡è¿­ä»£
å®ƒå’Œæ™®é€šå¹¿åº¦ä¼˜å…ˆæœç´¢çš„åŒºåˆ«åœ¨äºï¼Œæ™®é€šå¹¿åº¦ä¼˜å…ˆæœç´¢æ¯æ¬¡åªå–ä¸€ä¸ªå…ƒç´ æ‹“å±•ï¼Œè€Œè¿™é‡Œæ¯æ¬¡å– siä¸ªå…ƒç´ ã€‚åœ¨ä¸Šè¿°è¿‡ç¨‹ä¸­çš„ç¬¬ i æ¬¡è¿­ä»£å°±å¾—åˆ°äº†äºŒå‰æ ‘çš„ç¬¬ i å±‚çš„ si ä¸ªå…ƒç´ ã€‚
*/
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;        //å­˜å‚¨æ¯ä¸€å±‚çš„ç»“ç‚¹å€¼
        if(root == nullptr) return res;	//æ³¨æ„ğŸˆ³ï¸æ ‘

        queue<TreeNode*> q; //æ ‘çš„é˜Ÿåˆ—
        q.push(root);       //æ ¹å…ˆè¿›å…¥é˜Ÿåˆ—
        while(!q.empty()){  //ä¸ä¸ºç©º
            int s = q.size();
            res.push_back(vector<int>());   //å…ˆæ”¾å…¥ä¸€ä¸ªvector<int>
            for(int i=0;i<s;i++){
                auto node=q.front();q.pop();            //å–å‡ºé˜Ÿå¤´ï¼Œå¹¶åˆ é™¤é˜Ÿå¤´
                res.back().push_back(node->val);        //æ ¹ç»“ç‚¹å€¼å­˜å…¥vector<int>
                if(node->left)  q.push(node->left);     //å·¦ç»“ç‚¹ä¸ç©º,è¿›å…¥é˜Ÿåˆ—
                if(node->right)  q.push(node->right);   //å³ç»“ç‚¹ä¸ç©º,è¿›å…¥é˜Ÿåˆ—
            }
        }
        return res;
    }
};
```

#### [543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```java
/*
 ç›´å¾„é•¿åº¦ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼
 */
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans = 0;
        height(root);
        return ans; 
    }
    public int height(TreeNode node) {
        if (node == null) {
            return 0; // è®¿é—®åˆ°ç©ºèŠ‚ç‚¹äº†ï¼Œè¿”å›0
        }
        int L = height(node.left); // å·¦å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
        int R = height(node.right); // å³å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
        ans = Math.max(ans, L+R); // è®¡ç®—æ ¹èŠ‚ç‚¹nodeçš„ç›´å¾„å³L+R å¹¶æ›´æ–°ans
        return Math.max(L, R) + 1; // è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦
    }
}
```



#### [103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```C++
/*
æ€è·¯ï¼šæ ¹ç»“ç‚¹çš„æ’å…¥é¡ºåºä¸ä¸€æ ·ã€‚
    å¦‚æœä»å·¦è‡³å³ï¼Œæˆ‘ä»¬æ¯æ¬¡å°†è¢«éå†åˆ°çš„å…ƒç´ æ’å…¥è‡³åŒç«¯é˜Ÿåˆ—çš„æœ«å°¾ã€‚
    å¦‚æœä»å³è‡³å·¦ï¼Œæˆ‘ä»¬æ¯æ¬¡å°†è¢«éå†åˆ°çš„å…ƒç´ æ’å…¥è‡³åŒç«¯é˜Ÿåˆ—çš„å¤´éƒ¨ã€‚
*/
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;

        bool flag = true;   //ä»å·¦åˆ°å³
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            int s= q.size();
            res.push_back(vector<int>());
            for(int i=0;i<s;i++){
                auto node = q.front();q.pop();
                if(flag) res.back().push_back(node->val);               //æ’å…¥åˆ°æœ€åé¢
                else res.back().insert(res.back().begin(),node->val);   //æ’å…¥åˆ°æœ€å‰é¢
                   
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            flag=!flag;
        }
        return res;
    }
};
```

#### [107. äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```C++
/*
é¢˜æ„ï¼šè¿”å›å…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚åºéå†
æ€è·¯ï¼šåªéœ€è¦å°†æ¯æ¬¡å±‚åºéå†çš„ç»“ç‚¹çš„å®¹å™¨æ’å…¥åˆ°ç»“æœæœ€å‰é¢å°±å¯ä»¥äº†ï¼Œè¿™æ ·åé¢éå†çš„å°±å˜æˆå‰é¢çš„äº†ã€‚
*/
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
       vector<vector<int>> res;
       if(root == nullptr) return res;

       queue<TreeNode *> q;
       q.push(root);
       while(!q.empty()){
           int s = q.size();
           vector<int> t;
           for(int i=0;i<s;i++){
               auto node = q.front();q.pop();
               t.push_back(node->val);
               if(node->left) q.push(node->left);
               if(node->right) q.push(node->right);
           }
           res.insert(res.begin(),t);   //æ’å…¥åˆ°æœ€å‰é¢
       }
       return res;
    }
};
```

#### [199. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```C++
/*
äºŒå‰æ ‘çš„æ·±åº¦éå†å’Œå…ˆæ ¹éå†åŸºæœ¬ä¸Šæ˜¯ä¸€æ ·çš„,åªæ˜¯å…ˆæ ¹éå†æœ‰å·¦å³ä¹‹åˆ†,è€Œæ·±åº¦éå†æ²¡æœ‰å·¦å³ä¹‹åˆ†

æ€è·¯1:å±‚åºéå†ï¼Œè®°å½•ä¸‹æ¯å±‚çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
æ€è·¯2:å…ˆåºéå†(è¿™é‡Œæ˜¯æ ¹å³å·¦)ï¼Œè®°å½•ä¸‹æ¯å±‚çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚
*/
class Solution {
public:

    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;

        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int s= q.size();
            for(int i=0;i<s;i++){
                auto node = q.front();q.pop();
                if(i == s - 1) res.push_back(node->val);    //âš ï¸ä¿å­˜æœ€åä¸€ä¸ª
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```

#### [116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆâ­ï¸](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

![img](1.äºŒå‰æ ‘/116_sample.png)

```C++
/*
æ€è·¯ï¼šç”¨å±‚åºéå†ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥åœ¨éå†æ¯ä¸€å±‚çš„æ—¶å€™ä¿®æ”¹è¿™ä¸€å±‚èŠ‚ç‚¹çš„ next æŒ‡é’ˆï¼Œè¿™æ ·å°±å¯ä»¥æŠŠæ¯ä¸€å±‚éƒ½ç»„ç»‡æˆé“¾è¡¨ã€‚
ï¼ˆåˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚ï¼‰
*/
class Solution {
public:
    Node* connect(Node* root) {
        if(root == NULL) return NULL;

        queue<Node*> q;
        q.push(root);
        while(!q.empty()){      //å±‚åºéå†
            int s = q.size();
            for(int i=0;i<s;i++){
                auto node = q.front();q.pop();
                if(i < s - 1) node->next = q.front();  //å‰é¢çš„æŒ‡å‘åé¢ï¼Œfront()æŸ¥è¯¢é˜Ÿå¤´å…ƒç´ 
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return root;
    }
};
```

#### [117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/) â­ï¸

![img](1.äºŒå‰æ ‘/0dc6ed6ba29a12469f6254b1016c90608b852131939d03fd23d4bbd1aa0a9d78.png)

```C++
/*
ç©ºé—´å¤æ‚åº¦O(1)
æ€è·¯ï¼šä½¿ç”¨å·²å»ºç«‹çš„ next æŒ‡é’ˆï¼Œcur æŒ‡é’ˆåˆ©ç”¨ next ä¸åœçš„éå†å½“å‰å±‚ã€‚
	1ï¼‰å¦‚æœ cur çš„å·¦å³å­©å­ä¸ä¸º null å°±å°†å®ƒæ¥åˆ° tail åè¾¹ï¼Œç„¶åæ›´æ–°tailã€‚
	2ï¼‰å½“ cur ä¸º null çš„æ—¶å€™ï¼Œå†åˆ©ç”¨ dummy æŒ‡é’ˆå¾—åˆ°ä¸‹ä¸€å±‚çš„å¼€å§‹èŠ‚ç‚¹ã€‚
	éå†å®Œæ¯ä¸€å±‚ã€‚å°±è¦å°†dummy->nextèµ‹å€¼ç»™cur
dummy æŒ‡é’ˆåœ¨é“¾è¡¨ä¸­ç»å¸¸ç”¨åˆ°ï¼Œä»–åªæ˜¯ä¸ºäº†å¤„ç†å¤´ç»“ç‚¹çš„æƒ…å†µï¼Œå®ƒå¹¶ä¸å±äºå½“å‰é“¾è¡¨ã€‚
*/
class Solution {
public:
    Node* connect(Node* root) {
        if(root == NULL) return NULL;
        Node* cur = root;
        while(cur){
            Node* dummy = new Node();
            Node* tail = dummy;  //èµ‹å€¼ç»™tail
            while(cur){
                if(cur->left) {tail->next = cur->left;tail = tail->next;}
                if(cur->right) {tail->next = cur->right;tail= tail->next;}
                cur = cur->next;
            }
            cur = dummy->next; 
        }
        return root;
    }
};
```

#### [å‰‘æŒ‡ Offer 32 - I. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```
ç»å…¸ä¸­åº
```

#### [å‰‘æŒ‡ Offer 32 - II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

```
ç»å…¸ä¸­åº
```

#### [å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```
åŒ103
```



### BST+ä¸­åºéå†

#### [98. éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/validate-binary-search-tree/) â­ï¸

```C++
/*
äºŒå‰æœç´¢æ ‘
1.å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡<å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ã€‚
2.å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡>å®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ã€‚

å…ˆåºéå†
éå†æ—¶ï¼Œä¸ä»…å·¦ç»“ç‚¹å°äºæ ¹ç»“ç‚¹ï¼Œæ ¹ç»“ç‚¹å¤§äºå³ç»“ç‚¹ã€‚è€Œæ˜¯è¦æ•´ä¸ªå·¦å­æ ‘<æ ¹<å³å­æ ‘ã€‚æ­¤æ—¶éœ€è¦ä¿å­˜å­æ ‘çš„ä¸Šç•Œå’Œä¸‹ç•Œã€‚

æ€è·¯ï¼šåœ¨é€’å½’è°ƒç”¨å·¦å­æ ‘æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æŠŠä¸Šç•Œ upper æ”¹ä¸º root.valï¼Œå³è°ƒç”¨ helper(root.left, lower, root.val)ï¼Œå› ä¸ºå·¦å­æ ‘é‡Œæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ã€‚
åŒç†é€’å½’è°ƒç”¨å³å­æ ‘æ—¶ï¼Œæˆ‘ä»¬éœ€è¦æŠŠä¸‹ç•Œ lower æ”¹ä¸º root.valï¼Œå³è°ƒç”¨ helper(root.right, root.val, upper)ã€‚
*/
class Solution {
public:
    bool check(TreeNode* root,long long low,long long high){
        if(root == nullptr) return true;                        //æœ¬èº«ç©ºæˆ–è€…éå†å®Œ
        if(root->val <= low || root->val >= high) return false; //åˆ¤æ–­æ ¹ç»“ç‚¹å€¼(æ˜¯å¦è¶Šç•Œ)ï¼Œå†éå†å·¦å­æ ‘ï¼Œå³å­æ ‘
        return check(root->left,low,root->val) && check(root->right,root->val,high); 
        
    }
    bool isValidBST(TreeNode* root) {
        return check(root,LONG_MIN,LONG_MAX);//è¦long long(32,64éƒ½æ˜¯8å­—èŠ‚) 
      																			 //æˆ–è€…long(32ä½ 4å­—èŠ‚ï¼Œ64ä½8å­èŠ‚)
    }
};
```

#### [99. æ¢å¤äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/recover-binary-search-tree/) â­ï¸éš¾

![image.png](1.äºŒå‰æ ‘/26e9f631ec22f42f50099cf4fd9a55510ad0e7b0a4a836c772b6850591ddb737-image.png)

![4.jpg](1.äºŒå‰æ ‘/fde85797d0aa3cee9f8a84f39e820aed269f6c45b8eaf4d0672489c08f98090b-4.png)

![image-20211119191906437](1.äºŒå‰æ ‘/image-20211119191906437.png)

```C++
/*
3ç§è§£æ³•ï¼š
1.å…ˆå¼„ä¸ªvectorå®¹å™¨ã€‚ å†æ‘˜ä¸‹â€œæ ‘â€ä¸Šçš„æ•°æ®ï¼ˆä¸­åºéå†ï¼‰ã€‚ ç„¶åvectoræ’åºã€‚ å†æŠŠvectorå®¹å™¨é‡Œçš„æ•°æ®æŒ‚åœ¨â€œæ ‘ä¸Šâ€ï¼ˆä¸­åºéå†ï¼‰ã€‚ 
æ—¶é—´å¤æ‚åº¦ï¼šO(N)
ç©ºé—´å¤æ‚åº¦ï¼šO(N)
2.åªç”¨æ¯”è¾ƒå‰åè®¿é—®çš„èŠ‚ç‚¹å€¼ï¼Œprev ä¿å­˜ä¸Šä¸€ä¸ªè®¿é—®çš„èŠ‚ç‚¹ï¼Œå½“å‰è®¿é—®çš„æ˜¯ root èŠ‚ç‚¹ã€‚
æ¯è®¿é—®ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœprev.val>=root.valï¼Œå°±æ‰¾åˆ°äº†ä¸€å¯¹â€œé”™è¯¯å¯¹â€ã€‚
æ£€æŸ¥ä¸€ä¸‹å®ƒæ˜¯ç¬¬ä¸€å¯¹é”™è¯¯å¯¹ï¼Œè¿˜æ˜¯ç¬¬äºŒå¯¹é”™è¯¯å¯¹ã€‚
éå†ç»“æŸï¼Œå°±ç¡®å®šäº†å¾…äº¤æ¢çš„ä¸¤ä¸ªé”™è¯¯ç‚¹ï¼Œè¿›è¡Œäº¤æ¢ã€‚
æ—¶é—´å¤æ‚åº¦O(N)ï¼ŒNæ˜¯èŠ‚ç‚¹ä¸ªæ•°
ç©ºé—´å¤æ‚åº¦O(H)ï¼Œé€’å½’æ ˆçš„æ·±åº¦
3. Morriséå†æ˜¯äºŒå‰æ ‘éå†ç®—æ³•çš„è¶…å¼ºè¿›é˜¶ç®—æ³•ï¼Œè·Ÿé€’å½’ã€éé€’å½’ï¼ˆæ ˆå®ç°ï¼‰çš„ç©ºé—´å¤æ‚åº¦ï¼ŒMorriséå†å¯ä»¥å°†éé€’å½’éå†ä¸­çš„ç©ºé—´å¤æ‚åº¦é™ä¸ºO(1)
Morriséå†åˆ©ç”¨çš„æ˜¯æ ‘çš„å¶èŠ‚ç‚¹å·¦å³å­©å­ä¸ºç©ºï¼ˆæ ‘çš„å¤§é‡ç©ºé—²æŒ‡é’ˆï¼‰ï¼Œå®ç°ç©ºé—´å¼€é”€çš„æé™ç¼©å‡ã€‚
*/

//ç¬¬2ç§è§£æ³•
class Solution {
public:
    TreeNode* err1=nullptr;
    TreeNode* err2=nullptr;
    TreeNode* prev=new TreeNode(INT_MIN);	
    void LNR(TreeNode* root){
        if(root == nullptr) return;
        LNR(root->left);
        // è®°å½•ç¬¬ä¸€ä¸ªé”™è¯¯ç‚¹
        if(prev->val > root->val && err1 == nullptr) err1 = prev;
        // ç¬¬ä¸€ä¸ªé”™è¯¯ç‚¹å·²ç¡®å®š,è®°å½•ç¬¬äºŒä¸ªé”™è¯¯ç‚¹
        if(prev->val > root->val && err1 != nullptr) err2 = root;
        prev = root;    //æ›´æ–°prev
        LNR(root->right);
    }
    void recoverTree(TreeNode* root) {
        LNR(root);
        swap(err1->val,err2->val);
    }
};

//ç¬¬3ç§è§£æ³•
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *x = nullptr, *y = nullptr, *pred = nullptr, *predecessor = nullptr;

        while (root != nullptr) {
            if (root->left != nullptr) {
                // (1)predecessor èŠ‚ç‚¹å°±æ˜¯å½“å‰ root èŠ‚ç‚¹å‘å·¦èµ°ä¸€æ­¥ï¼Œç„¶åä¸€ç›´å‘å³èµ°è‡³æ— æ³•èµ°ä¸ºæ­¢
                predecessor = root->left;
                while (predecessor->right != nullptr && predecessor->right != root) {
                    predecessor = predecessor->right;
                }
                
                // (2)è®© predecessor çš„å³æŒ‡é’ˆæŒ‡å‘ rootï¼Œç»§ç»­éå†å·¦å­æ ‘
                if (predecessor->right == nullptr) {
                    predecessor->right = root; 
                    root = root->left;          //è®¿é—®å·¦å­©å­
                }
                // (3)è¯´æ˜å·¦å­æ ‘å·²ç»è®¿é—®å®Œäº†ï¼Œæˆ‘ä»¬éœ€è¦æ–­å¼€é“¾æ¥
                else {
                    //è®°å½•é”™è¯¯ç»“ç‚¹
                    if (pred != nullptr && root->val < pred->val) {
                        x = root;
                        if (y == nullptr) {
                            y = pred;
                        }
                    }

                    pred = root; //æ›´æ–°pred
                    predecessor->right = nullptr; //ç½®ä¸ºç©º
                    root = root->right;           //è®¿é—®å³å­©å­
                }
            }
            // å¦‚æœæ²¡æœ‰å·¦å­©å­ï¼Œåˆ™ç›´æ¥è®¿é—®å³å­©å­
            else {
                //è®°å½•é”™è¯¯ç»“ç‚¹
                if (pred != nullptr && root->val < pred->val) {
                    x = root;
                    if (y == nullptr) {
                        y = pred;
                    }
                }

                pred = root;//æ›´æ–°pred
                root = root->right; //ç›´æ¥è®¿é—®å³å­©å­
            }
        }
        swap(x->val, y->val);
    }
};
```

#### [230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ ](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```C++
/*
Â æ€è·¯ï¼šä¸­åºéå†å®Œå°±æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ—ï¼Œå–å‡ºç¬¬kä¸ªå…ƒç´ å°±æ˜¯ç¬¬kå°çš„å…ƒç´ ã€‚
*/
class Solution {
public:
    void LNR(TreeNode *root,vector<int> &res){
        if(root == nullptr) return;
        LNR(root->left,res);
        res.push_back(root->val);
        LNR(root->right,res);
    }
    int kthSmallest(TreeNode* root, int k) {
        vector<int> res;
        LNR(root,res);
        return res[k-1];
    }
};
```

#### [å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹âš ï¸](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```C++
//ä¸­åºéå†(âš ï¸è¿™é‡Œæ˜¯å³æ ¹å·¦ï¼Œç”±äºæ˜¯é€’å½’)
```



#### [285.äºŒå‰æœç´¢æ ‘çš„åç»­ç»“ç‚¹â­ï¸](https://leetcode-cn.com/problems/inorder-successor-in-bst/)

ç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘å’Œå…¶ä¸­çš„æŸä¸€ä¸ªç»“ç‚¹ï¼Œè¯·ä½ æ‰¾å‡ºè¯¥ç»“ç‚¹åœ¨æ ‘ä¸­é¡ºåºåç»§çš„èŠ‚ç‚¹ã€‚

ç»“ç‚¹ p çš„åç»§æ˜¯å€¼**æ¯” p.val å¤§**çš„ç»“ç‚¹ä¸­**é”®å€¼æœ€å°**çš„ç»“ç‚¹ã€‚

```C++
/*
æ€è·¯ï¼šå¦‚æœpæ¯”å½“å‰èŠ‚ç‚¹å°ï¼Œè¯´æ˜åœ¨å·¦å­æ ‘ï¼Œres=rootï¼›å¦åˆ™å»å³å­æ ‘æœç´¢ã€‚
*/
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        TreeNode* res = NULL;
        while (root) {
            if (p->val < root->val) {	
                res = root;					//åœ¨å·¦å­æ ‘çš„æ ¹ï¼ˆåŒæ—¶ï¼Œé”®å€¼æœ€å°ï¼Œæœ€å·¦è¾¹ï¼‰âš ï¸
                root = root->left;
            } else {
                root = root->right;
            }
        }
        return res;
    }
};
```

#### [äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹â­ï¸ ](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=196&tqId=39730&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D%25E7%25BB%2593%25E7%2582%25B9%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196&difficulty=undefined&judgeStatus=undefined&tags=&title=%E7%BB%93%E7%82%B9)

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        if (pNode.right != null) {
            TreeLinkNode node = pNode.right;    //åç»§ç»“ç‚¹ï¼šä¸­åºéå†çš„ä¸‹ä¸€ä¸ªç»“ç‚¹
            while (node.left != null)
                node = node.left;
            return node;
        } else {
            while (pNode.next != null) {    //æ‰¾å‡ºå…¶çˆ¶ç»“ç‚¹
                TreeLinkNode parent = pNode.next;
                if (parent.left == pNode)    //pNodeæ˜¯parentçš„å·¦ç»“ç‚¹
                    return parent;
                pNode = pNode.next;
            }
        }
        return null;
    }
}
```



#### [272.æœ€æ¥è¿‘çš„äºŒå‰æœç´¢æ ‘å€¼2](https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii/)

```C++
/*

*/
```

#### [å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

```C++
/*T,S:O(n)
å…ˆåºéå†ï¼špreæš‚å­˜å‰é¢çš„ç»“ç‚¹ï¼Œhead
*/
class Solution {
private:
    Node *pre, *head;   //preæš‚å­˜å‰é¢çš„ç»“ç‚¹
    void dfs(Node* cur) {
        if(cur == nullptr) return;
        dfs(cur->left);
        if(pre != nullptr) pre->right = cur;    //pre->ræŒ‡å‘cur
        else head = cur;
        cur->left = pre;                        //cur->læŒ‡å‘pre
        pre = cur;  //æ›´æ–°pre
        dfs(cur->right);
    }
public:
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr) return nullptr;
        dfs(root);
        head->left = pre;   //æœ€å
        pre->right = head;
        return head;
    }
};
```



### æ··åˆ

#### [257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](https://leetcode-cn.com/problems/binary-tree-paths/)

```C++
/*
//T,S:O(n^2) æ ¹å·¦å³
æ€è·¯ï¼šå…ˆåºéå†ï¼Œå‘ç°å¶å­ç»“ç‚¹å°±åŠ å…¥ç»“æœé›†ä¸­ï¼›æ²¡æœ‰å°±ç»§ç»­é€’å½’å·¦å³å­æ ‘ã€‚
*/

class Solution {
public:
    void getPath(TreeNode* root,string path,vector<string> &res){ //âš ï¸stringç±»ä¸åŠ &
        if(root == nullptr) return;
        path += to_string(root->val);
        //å¶å­ç»“ç‚¹ï¼ŒåŠ å…¥ç»“æœ
        if(root->left == nullptr && root->right == nullptr){
            res.push_back(path);
        }else{   //ä¸æ˜¯å¶å­ç»“ç‚¹ï¼Œé€’å½’å·¦å³å­æ ‘
            path += "->";
            getPath(root->left,path,res);
            getPath(root->right,path,res);
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        string path;
        getPath(root,path,res);
        return res;       
    }
};
```

#### [270.æœ€æ¥è¿‘çš„äºŒå‰æœç´¢æ ‘å€¼](https://leetcode-cn.com/problems/closest-binary-search-tree-value/)

```C++
/*

*/
```



#### [255.éªŒè¯å‰åºéå†åºåˆ—äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/)

```C++

```

#### [114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```C++
/*
æ€è·¯ï¼šå…ˆåºéå†å°†äºŒå‰æ ‘å–ä¸‹æ¥ï¼Œå†éå†ä¸€éå˜æˆé“¾è¡¨
âš ï¸ï¼šå·¦å­©å­ä¸ºç©ºï¼Œå³å­©å­èµ‹å€¼å½“å‰ç»“ç‚¹
*/
class Solution {
public:
    void flatten(TreeNode* root) {
        vector<TreeNode*> res;
        NLR(root,res);
        int s =res.size();
        for(int i=1;i<s;i++){
            TreeNode* prev = res[i-1],*cur = res[i];
            prev->left = nullptr;   //å‰é©±ç»“ç‚¹ä¸ºç©º
            prev->right = cur;      //å‰é©±ç»“ç‚¹çš„å³ç»“ç‚¹ä¸ºå½“å‰ç»“ç‚¹
        }
    }
    void NLR(TreeNode* root,vector<TreeNode*> &res){
        if(root == nullptr) return;
        res.push_back(root);
        NLR(root->left,res);
        NLR(root->right,res);
    }
};
```

#### [156.ä¸Šä¸‹ç¿»è½¬äºŒå‰æ ‘](https://leetcode-cn.com/problems/binary-tree-upside-down/)

```

```

#### [å‰‘æŒ‡ Offer 37. åºåˆ—åŒ–äºŒå‰æ ‘](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

#### [297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) â­ï¸éš¾

```C++
/*

*/

```

#### [å‰‘æŒ‡ Offer 33. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

```
//ååºéå†ï¼Œå•è°ƒæ ˆ
//T,S:O(n)
```

### é€’å½’

### è®¡ç®—ä¸ªæ•°ï¼Œé€šè¿‡ç•Œå®š(1,n)æ±‚è§£

#### [95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```C++
/*
é¢˜æ„ï¼šç»™å®šä¸€ä¸ªæ•´æ•° nï¼Œç”Ÿæˆæ‰€æœ‰ç”± 1 ... n ä¸ºèŠ‚ç‚¹æ‰€ç»„æˆçš„ äºŒå‰æœç´¢æ ‘ ã€‚
æ€è·¯ï¼š
å¦‚æœæˆ‘ä»¬æšä¸¾æ ¹èŠ‚ç‚¹çš„å€¼ä¸º iï¼Œ
é‚£ä¹ˆæ ¹æ®äºŒå‰æœç´¢æ ‘çš„æ€§è´¨æˆ‘ä»¬å¯ä»¥çŸ¥é“å·¦å­æ ‘çš„èŠ‚ç‚¹å€¼çš„é›†åˆä¸º [1â€¦iâˆ’1]ï¼Œå³å­æ ‘çš„èŠ‚ç‚¹å€¼çš„é›†åˆä¸º [i+1â€¦n]
å†æšä¸¾å·¦ï¼Œå³å­æ ‘ï¼ŒæŒ‚åˆ°æ ¹ç»“ç‚¹ä¸Šï¼Œå°†æ ¹ç»“ç‚¹åŠ å…¥åˆ°ç»“æœé›†ä¸­
*/
class Solution {
public:
    vector<TreeNode*> generateTrees(int st,int ed){
        if(st > ed) return {nullptr};//{nullptr} é•¿åº¦ä¸º1ï¼Œ{}é•¿åº¦ä¸º0
        vector<TreeNode*> allTrees;
        for(int i=st;i <= ed; i++){
            //è·å¾—æ‰€æœ‰å¯è¡Œçš„å·¦å­æ ‘é›†åˆ
            vector<TreeNode*> lTrees = generateTrees(st,i-1);
            //è·å¾—æ‰€æœ‰å¯è¡Œçš„å³å­æ ‘é›†åˆ
            vector<TreeNode*> rTrees = generateTrees(i+1,ed);
            for(auto& l:lTrees){    //æšä¸¾å·¦ï¼Œå³å­æ ‘ï¼ŒæŒ‚åˆ°æ ¹ç»“ç‚¹ä¸Š
                for(auto& r:rTrees){
                    TreeNode* cur = new TreeNode(i);  //æ ¹ç»“ç‚¹
                    allTrees.push_back(cur);
                    cur->left = l;
                    cur->right = r;         
                }
            }
        }
        return allTrees;
    }
    vector<TreeNode*> generateTrees(int n) {
        if(!n) return {};
        return generateTrees(1,n);
    }
};
```

### å…ˆå·¦å³åè‡ªå·±

#### [96. ä¸åŒçš„äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/unique-binary-search-trees/)

![image-20210306160658602](1.äºŒå‰æ ‘/image-20210306160658602.png)

![image-20210306161232086](1.äºŒå‰æ ‘/image-20210306161232086.png)

```C++
/*
ç»™å®šä¸€ä¸ªæ•´æ•° nï¼Œæ±‚ä»¥ 1 ... n ä¸ºèŠ‚ç‚¹ç»„æˆçš„äºŒå‰æœç´¢æ ‘æœ‰å¤šå°‘ç§ï¼Ÿ
å¡ç‰¹å…°æ•°G(n)
*/
class Solution {
public:,
    int numTrees(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        int res = 0;
        for (int i = 1; i <= n; i++) {
            res += numTrees(i - 1) * numTrees(n - i);
        }
        return res;
    }
};
```

#### [124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) ğŸ€„ï¸

![image-20210308095058804](1.äºŒå‰æ ‘/image-20210308095058804.png)

```C++
/*  ä»ä¸‹å¾€ä¸Šï¼šååºéå†ã€‚
é¢˜æ„ï¼šç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶æœ€å¤§è·¯å¾„å’Œ
æ€è·¯ï¼šè€ƒè™‘ä¸€ä¸ªäºŒå‰æ ‘å•å…ƒï¼šæœ‰3ç§æƒ…å†µï¼ša+b+c,a+b,a+c
    a
   / \
  b   c
é€’å½’å·¦å³å­æ ‘ï¼Œæ›´æ–°3ç§æƒ…å†µçš„æœ€å¤§å’Œï¼Œè¿”å›è¾ƒå¤§å€¼a+max(b,+c)
*/
class Solution {
public:
    int res = INT_MIN;    
    int maxSum(TreeNode* root){
        if(root == nullptr) return 0;	//base case
        int l = max(maxSum(root->left),0); //å­é—®é¢˜:å–maxï¼Œå¦‚æœç»“ç‚¹è´Ÿæ•°å°±å–0
        int r = max(maxSum(root->right),0);//å­é—®é¢˜
        res = max(res,l + r + root->val);	//é¢å¤–ï¼šäººå­—å½¢ç­”æ¡ˆ
        return root->val + max(l,r);	//é€’å½’
    }
    int maxPathSum(TreeNode* root) {
        maxSum(root);
        return res;
    }
};
```

#### [235. äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

#### [236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```C++
/*
æ€è·¯ï¼šå¦‚æœrootç­‰äºqæˆ–è€…pï¼Œæˆ–è€…NULLï¼Œç›´æ¥è¿”å›root
é€’å½’å·¦å­æ ‘
é€’å½’å³å­æ ‘
å·¦ç»“ç‚¹ï¼Œå³ç»“ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›rootï¼ˆæœ€ç»ˆç­”æ¡ˆï¼‰
è¿”å› å·¦ç»“ç‚¹æˆ–è€…å³ç»“ç‚¹ï¼Œå“ªä¸ªä¸ç©ºè¿”å›å“ªä¸ª
*/
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL || root == p || root == q) return root;
        TreeNode* l = lowestCommonAncestor(root->left,p,q);
        TreeNode* r = lowestCommonAncestor(root->right,p,q);
        if(l != NULL && r != NULL) return root;	//å·¦å³å­æ ‘ä¸ç©º
        return l!=NULL?l:r;	//å“ªä¸ªä¸ç©ºï¼Œè¿”å›å“ªä¸ª
    }
};
```

#### [250.ç»Ÿè®¡åŒå€¼å­æ ‘](https://leetcode-cn.com/problems/count-univalue-subtrees/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œç»Ÿè®¡è¯¥äºŒå‰æ ‘æ•°å€¼ç›¸åŒçš„å­æ ‘ä¸ªæ•°ã€‚

åŒå€¼å­æ ‘æ˜¯æŒ‡è¯¥å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æ‹¥æœ‰ç›¸åŒçš„æ•°å€¼ã€‚

ç¤ºä¾‹ï¼š

è¾“å…¥: root = [5,1,5,5,5,null,5]

```
          5
         / \
        1   5
       / \   \
      5   5   5
```

è¾“å‡º: 4

```C++

```

#### [333.æœ€å¤§BSTå­æ ‘](https://leetcode-cn.com/problems/largest-bst-subtree/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€å¤§çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰å­æ ‘ï¼Œå¹¶è¿”å›è¯¥å­æ ‘çš„å¤§å°ã€‚å…¶ä¸­ï¼Œæœ€å¤§æŒ‡çš„æ˜¯å­æ ‘èŠ‚ç‚¹æ•°æœ€å¤šçš„ã€‚

```C++

```

### å…ˆè‡ªå·±åå·¦å³

#### [100. ç›¸åŒçš„æ ‘](https://leetcode-cn.com/problems/same-tree/)

```C++
/*
1.å¦‚æœä¸¤ä¸ªäºŒå‰æ ‘éƒ½ä¸ºç©ºï¼Œåˆ™ä¸¤ä¸ªäºŒå‰æ ‘ç›¸åŒã€‚
2.å¦‚æœä¸¤ä¸ªäºŒå‰æ ‘ä¸­æœ‰ä¸”åªæœ‰ä¸€ä¸ªä¸ºç©ºï¼Œåˆ™ä¸¤ä¸ªäºŒå‰æ ‘ä¸€å®šä¸ç›¸åŒã€‚

3.å¦‚æœä¸¤ä¸ªäºŒå‰æ ‘éƒ½ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆé¦–å…ˆåˆ¤æ–­å®ƒä»¬çš„æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸åŒï¼Œ
4.è‹¥ä¸ç›¸åŒåˆ™ä¸¤ä¸ªäºŒå‰æ ‘ä¸€å®šä¸åŒï¼Œè‹¥ç›¸åŒï¼Œ
  å†åˆ†åˆ«åˆ¤æ–­ä¸¤ä¸ªäºŒå‰æ ‘çš„å·¦å­æ ‘æ˜¯å¦ç›¸åŒä»¥åŠå³å­æ ‘æ˜¯å¦ç›¸åŒã€‚
  è¿™æ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé€’å½’åœ°åˆ¤æ–­ä¸¤ä¸ªäºŒå‰æ ‘æ˜¯å¦ç›¸åŒã€‚
*/
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == nullptr && q == nullptr){return true;}      //éƒ½ä¸ºç©º
        else if( p == nullptr || q == nullptr){return false;}   //1ä¸ªä¸ºç©ºï¼Œ1ä¸ªä¸ç©º
        else if( p->val != q->val){return false;}   //å€¼ä¸ç›¸ç­‰
        else{return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);} //å€¼ç›¸ç­‰ï¼Œé€’å½’
    }
};
```

#### [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

#### [å‰‘æŒ‡ Offer 55 - I. äºŒå‰æ ‘çš„æ·±åº¦](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/) åŒä¸Š

![image-20210308095241593](1.äºŒå‰æ ‘/image-20210308095241593.png)

```C++
/*  ä»ä¸‹å¾€ä¸Šï¼šååºéå†ã€‚
æ€è·¯ï¼šå¦‚æœä¸ºç©ºï¼Œç›´æ¥è¿”å›0
è¿”å› é€’å½’1+maxï¼ˆå·¦å­æ ‘çš„æ·±åº¦ï¼Œå³å­æ ‘çš„æ·±åº¦ï¼‰
*/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        return 1+max(maxDepth(root->left),maxDepth(root->right));	//æ ¹ç»“ç‚¹+å·¦å³å­æ ‘çš„æ·±åº¦
    }
};
```

#### è·å–äºŒå‰æ ‘çš„ç»“ç‚¹æ•°

```C++
/*
æ€è·¯ï¼šä¸ºç©ºï¼Œç›´æ¥è¿”å›0
è¿”å› é€’å½’1+å·¦å­æ ‘+å³å­æ ‘çš„ç»“ç‚¹æ•°
*/
int getAllNode(TreeNode* root){
  if(root == NULL) return 0;
	return 1 + getAllNode(root->left)+getAllNode(root->right);
}
```

#### è·å–äºŒå‰æ ‘çš„å¶å­ç»“ç‚¹æ•°

```C++
/*
æ€è·¯ï¼šå¦‚æœæ ¹ç»“ç‚¹ä¸ºç©ºï¼Œç›´æ¥è¿”å›0
å¦‚æœå·¦ç»“ç‚¹å’Œå³ç»“ç‚¹åŒæ—¶ä¸ºç©ºï¼Œç›´æ¥è¿”å›1
è¿”å› é€’å½’å·¦å­æ ‘+å³å­æ ‘çš„ç»“ç‚¹æ•°
*/
int leafCount(TreeNode* root){
	if(root == NULL) return 0;
  if(root->left == NULL && root->right == NULL) return 1;
  return leafCount(root->left)+leafCount(root->right);//ä¸åŒ…å«æ ¹ç»“ç‚¹
}
```

#### æŸç»“ç‚¹æ˜¯å¦åœ¨äºŒå‰æ ‘ä¸­

```C++
bool isExist(TreeNode* root,TreeNode* p){
	if(root == NULL) return false;
  if(root->val == p->val) return true;		//æ ¹
  if(isExist(root->left,p)) return true;	//å·¦
  else return isExist(root->right,p);			//å³
}
```



#### [å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

#### [105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) ğŸ€„ï¸

![image-20210306175110221](/Users/zcz/Desktop/images/image-20210306175110221.png)

![image-20210306175018888](1.äºŒå‰æ ‘/image-20210306175018888.png)

```C++
/*
æ€è·¯ï¼šå…ˆåºçš„ç¬¬ä¸€ä¸ªå°±æ˜¯æ ¹ç»“ç‚¹ï¼Œå–å‡ºæ¥ï¼›
å†æŸ¥æ‰¾æ ¹ç»“ç‚¹åœ¨ä¸­åºä¸­çš„ä½ç½®ï¼›
ç„¶åé€’å½’å¯»æ‰¾å‰åºå’Œä¸­åºçš„å·¦åŒºé—´ï¼Œå³åŒºé—´ã€‚
*/
class Solution {
public:
    unordered_map<int,int> map;
    TreeNode* buildTree(vector<int> &preorder,int preL,int preR,int inL,int inR){
        if(preL > preR || inL > inR) return nullptr;    //è¶…å‡ºèŒƒå›´
        int rootVal = preorder[preL];           //å…ˆåºéå†çš„ç¬¬ä¸€ä¸ªæ˜¯æ ¹ï¼Œå–å‡ºæ ¹ç»“ç‚¹çš„å€¼
        int pIndex = map[rootVal];              //æŸ¥è¯¢æ ¹åœ¨ä¸­åºåºåˆ—ä¸­çš„ä½ç½®
        
        TreeNode* root = new TreeNode(rootVal);  //newæ ¹ç»“ç‚¹
        //å‰åºï¼Œä¸­åºçš„å·¦åŒºé—´ 
        root->left = buildTree(preorder,preL+1,pIndex-inL+preL,inL,pIndex-1);
        //å‰åºï¼Œä¸­åºçš„å³åŒºé—´
        root->right = buildTree(preorder,pIndex-inL+preL+1,preR,pIndex+1,inR);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int preLen = preorder.size();   //å‰åºç»“ç‚¹æ•°
        int inLen = inorder.size();     //ä¸­åºç»“ç‚¹æ•°
        for(int i=0;i < inLen; i++) map.insert({inorder[i],i});   //å“ˆå¸Œå…ˆå­˜å‚¨ä¸­åºï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¿«
        return buildTree(preorder,0,preLen-1,0,inLen-1);         
    }
};
```

#### [106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

![image-20210306194848625](1.äºŒå‰æ ‘/image-20210306194848625.png)

```C++
/*
åŒ105ç›¸åŒçš„æ€è·¯
*/
class Solution {
public:
    unordered_map<int,int> map;
    TreeNode* buildTree(vector<int>& postorder,int postL,int postR,int inL,int inR){
        if(postL > postR || inL >inR) return nullptr;  
        int rootVal = postorder[postR];	//å–å‡ºæ ¹ç»“ç‚¹çš„å€¼
        int pIndex = map[rootVal];	//æŸ¥è¯¢æ ¹åœ¨ä¸­åºåºåˆ—ä¸­çš„ä½ç½®
      	TreeNode* root = new TreeNode(rootVal);	//newæ ¹ç»“ç‚¹
				//å‰åºï¼Œååºçš„å·¦åŒºé—´  ä»¥åŠ //å‰åºï¼Œååºçš„å³åŒºé—´ 
        root->left = buildTree(postorder,postL,postL+pIndex-inL-1,inL,pIndex-1);
        root->right = buildTree(postorder,postL+pIndex-inL,postR-1,pIndex+1,inR);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int inLen = inorder.size();		//ååºç»“ç‚¹æ•°
        int postLen = postorder.size();		//å‰åºç»“ç‚¹æ•°

        for(int i=0;i<inLen;i++) map.insert({inorder[i],i}); //å“ˆå¸Œå…ˆå­˜å‚¨ä¸­åºï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¿«
        return buildTree(postorder,0,postLen-1,0,inLen-1);

    }
};
```

#### [889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

#### [108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```C++
/*
æ€è·¯ï¼šåŒ109
*/
class Solution {
public:
    TreeNode* buildTree(vector<int>& nums,int l,int r){
        if(l > r) return nullptr;
        int mid = (l+r+1)>>1;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = buildTree(nums,l,mid-1);
        root->right = buildTree(nums,mid+1,r);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildTree(nums,0,nums.size()-1);
    }
};
```

#### [109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/) ğŸ€„ï¸

```C++
/*
é¢˜æ„ï¼šå°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘,å¹¶ä¸”é«˜åº¦å¹³è¡¡
æ€è·¯ï¼š
æ„é€ å‡ºçš„äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ç»“æœå°±æ˜¯é“¾è¡¨æœ¬èº«ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†åˆ†æ²»å’Œä¸­åºéå†ç»“åˆèµ·æ¥ï¼Œå‡å°‘æ—¶é—´å¤æ‚åº¦ã€‚
	ä¸­ä½æ•°èŠ‚ç‚¹å¯¹åº”çš„ç¼–å·ä¸º mid=left+(right-left)/2+1ï¼›
	å·¦å³å­æ ‘å¯¹åº”çš„ç¼–å·èŒƒå›´åˆ†åˆ«ä¸º [left,midâˆ’1] å’Œ [mid+1,right]ã€‚

æ•°ç»„ä¸‹æ ‡0,1,2,3,4 åŒºåˆ« 
(r+l+1)/2			(1)	2 1 0 4 3	åŒºé—´å³è¾¹ä¼˜å…ˆ
l+(r-l)/2			(2)	2 0 1 3 4
*/
class Solution {
public:
    int getLength(ListNode* head){
          int len = 0;
        	while(head){head = head->next;len++;}
        	return len;
    }
    TreeNode*  buildTree(ListNode* &head,int l,int r){//âš ï¸è®°å¾—headåŠ &
        if(l > r) return nullptr;
        int mid = (r+l+1)>>1;                    //âš ï¸ä¸­é—´ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹
        TreeNode* root = new TreeNode();        //æ ¹ç»“ç‚¹
        //ä¸­åºéå†
        root->left = buildTree(head,l,mid-1);   //é€’å½’å·¦å­æ ‘
        root->val = head->val;                  //âš ï¸ä¸­åºå¿…é¡»è¿™é‡Œèµ‹å€¼ç»™æ ¹ç»“ç‚¹
        head = head->next;                      //âš ï¸æ³¨æ„æ›´æ–°head
        root->right = buildTree(head,mid+1,r);  //é€’å½’å³å­æ ‘
        return root;
    }
    TreeNode* sortedListToBST(ListNode* head) {
        int len = getLength(head);
        return buildTree(head,0,len-1);
    }
};
```

#### [110. å¹³è¡¡äºŒå‰æ ‘](https://leetcode-cn.com/problems/balanced-binary-tree/)

#### [å‰‘æŒ‡ Offer 55 - II. å¹³è¡¡äºŒå‰æ ‘](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

```C++
/*
è‡ªé¡¶å‘ä¸‹ï¼šT:O(n^2)
è‡ªåº•å‘ä¸Šï¼šT:Oï¼ˆn^2ï¼‰
æ€è·¯ï¼šååºéå†ï¼šå…ˆé€’å½’åœ°åˆ¤æ–­å…¶å·¦å³å­æ ‘æ˜¯å¦å¹³è¡¡ï¼Œå†åˆ¤æ–­ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘æ˜¯å¦å¹³è¡¡
*/
class Solution {
public:
    int height(TreeNode* root){
        if(root ==nullptr) return 0;    //ç¬¦åˆ
        int l = height(root->left);
        int r = height(root->right);
        if(l == -1 || r == -1 || abs(r-l) > 1) return -1; //ä¸ç¬¦åˆ
        else return max(l,r)+1;
    }
    bool isBalanced(TreeNode* root) {
        return height(root) >= 0;
    }
};
```

#### [111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```C++
/*
é¢˜æ„ï¼šæœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚
æ€è·¯ï¼š
æ‰¾å‡º2ä¸ªåŸå§‹çŠ¶æ€ï¼šä¸ºç©ºç›´æ¥è¿”å›0ï¼›å·¦å³ç»“ç‚¹ä¸ºç©ºï¼Œè¿”å›1ï¼›
å†é€’å½’å·¦å­æ ‘ï¼Œå³å­æ ‘çš„æœ€å°æ·±åº¦ï¼Œå–è¾ƒå°çš„+1å°±æ˜¯ç­”æ¡ˆ
*/
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        if(root->left == nullptr && root->right == nullptr) return 1;
        int res = INT_MAX;
        if(root->left) res=min(minDepth(root->left),res);
        if(root->right) res=min(minDepth(root->right),res);
        return 1+res;
    }
};
```

#### [669. ä¿®å‰ªäºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```

```



#### [112. è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)

```C++
//T:O(H) S:O(N)
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        if(root->left == nullptr && root->right == nullptr) return targetSum == root->val;
        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right,targetSum-root->val);
    }
};
```

#### [113. è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)

#### [å‰‘æŒ‡ Offer 34. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```C++
//T:O(n^2) S:O(n)
class Solution {
public:
    vector<vector<int>> res;
    void dfs(TreeNode* root, int targetSum,vector<int> path){
        if (root == nullptr) return;
        path.push_back(root->val);
        targetSum -= root->val;
        if (root->left == nullptr && root->right == nullptr && targetSum == 0) {
            res.push_back(path);
        }
        dfs(root->left, targetSum,path);
        dfs(root->right, targetSum,path);
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root,targetSum,vector<int>());
        return res;
    }   
};
```

#### [437. è·¯å¾„æ€»å’Œ III](https://leetcode-cn.com/problems/path-sum-iii/)

```C++
/*
1.é€’å½’ï¼šT:O(n^2),S:O(n)
2.å‰ç¼€å’Œï¼šT,S:O(n)
*/
class Solution {
public:
    int res=0;
    void dfs(TreeNode* root, int targetSum){
        if (root == nullptr) return;
        if (targetSum == root->val) res++;
        dfs(root->left, targetSum-root->val);
        dfs(root->right, targetSum-root->val);
    }
    int pathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return 0;
        dfs(root,targetSum);    //å…ˆé€’å½’æ ¹ç»“ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯å¾„ï¼›å†é€’å½’å­æ ‘çš„è·¯å¾„
        pathSum(root->left,targetSum);
        pathSum(root->right,targetSum);
        return res;
    }
};


```

#### [1110. åˆ ç‚¹æˆæ—](https://leetcode-cn.com/problems/delete-nodes-and-return-forest/)

```C++
/*Tï¼šO(n) S:O(H+N)
æ€è·¯ï¼šå…ˆåºéå†ï¼šå¦‚æœ node æ˜¯root è€Œä¸”æ²¡æœ‰è¢«åˆ é™¤ï¼Œåˆ™åŠ å…¥ç­”æ¡ˆ
*/
class Solution {
public:
    vector<TreeNode*> result;
    set<int> to_delete_set;
    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
        for (int i : to_delete) //1.å­˜å…¥set
            to_delete_set.insert(i);
        helper(root, result, to_delete_set, true);
        return result;
    }
    TreeNode* helper(TreeNode* node, vector<TreeNode*>& result, set<int>& to_delete_set, bool is_root) {
        if (node == NULL) return NULL;
        bool deleted = to_delete_set.count(node->val);    //2.åˆ¤æ–­æ˜¯å¦åˆ é™¤
        if (is_root && !deleted) result.push_back(node);    //æ˜¯æ ¹ç»“ç‚¹ä¸”ä¸åˆ é™¤
        node->left = helper(node->left, result, to_delete_set, deleted);
        node->right =  helper(node->right, result, to_delete_set, deleted);
        return deleted ? NULL : node;  //3.
    }
};
```



#### [129. æ±‚æ ¹åˆ°å¶å­èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/) ğŸ€„ï¸

![image-20210308095648125](1.äºŒå‰æ ‘/image-20210308095648125.png)

```C++
/*ä»ä¸Šåˆ°ä¸‹:å…ˆåºéå†
æ€è·¯ï¼š
*/
class Solution {
public:
    int res=0;
    void get_sum(TreeNode* root,int num){
        if(root == nullptr) return ;//base case æ ¹ç»“ç‚¹
        num = root->val+num*10;     
        if(root->left == nullptr && root->right == nullptr) res += num; //base case å¶ç»“ç‚¹
        
        if(root->left) get_sum(root->left,num);     //å­é—®é¢˜
        if(root->right) get_sum(root->right,num);   //å­é—®é¢˜
    } 
    int sumNumbers(TreeNode* root) {
        get_sum(root,0);
        return res;
    }
};
```

#### [222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```C++
/*Tï¼šO(logâ¡2n) S:O(1)
æ€è·¯ï¼šäºŒåˆ†æŸ¥æ‰¾ + ä½è¿ç®—
*/

```

#### [å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

#### [226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode-cn.com/problems/invert-binary-tree/)

> Qï¼š ä¸ºä½•éœ€è¦æš‚å­˜ rootçš„å·¦å­èŠ‚ç‚¹ï¼Ÿ
> Aï¼š åœ¨é€’å½’å³å­èŠ‚ç‚¹ â€œroot.left=mirrorTree(root.right);â€ æ‰§è¡Œå®Œæ¯•åï¼Œ root.leftçš„å€¼å·²ç»å‘ç”Ÿæ”¹å˜ï¼Œæ­¤æ—¶é€’å½’å·¦å­èŠ‚ç‚¹ mirrorTree(root.left) åˆ™ä¼šå‡ºé—®é¢˜ã€‚

```C++
//é€’å½’ Tï¼ŒSï¼šO(n)
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        root->left = right;
        root->right = left;
        return root;
    }
};
```

#### [101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode-cn.com/problems/symmetric-tree/)

#### [å‰‘æŒ‡ Offer 28. å¯¹ç§°çš„äºŒå‰æ ‘](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

![image-20210722224510100](1.äºŒå‰æ ‘/image-20210722224510100.png)

```C++
//T,S:O(n)
class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};

```

#### [298.äºŒå‰æ ‘æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence/)

```C++
//å…ˆåºéå†ï¼šè‡ªé¡¶å‘ä¸‹ï¼šT,S:O(n)
//å…ˆé€’å½’æ ¹ç»“ç‚¹length =(parent != null && p.val == parent.val + 1)? length + 1 : 1;å†é€’å½’å·¦å³å­æ ‘
public int longestConsecutive(TreeNode root) {
    return dfs(root, null, 0);
}

private int dfs(TreeNode p, TreeNode parent, int length) {
    if (p == null) return length;
    length = (parent != null && p.val == parent.val + 1) ? length + 1 : 1;
    return Math.max(length, Math.max(dfs(p.left, p, length),
                                     dfs(p.right, p, length)));
}
```

#### [366.å¯»æ‰¾äºŒå‰æ ‘çš„å¶å­ç»“ç‚¹](https://leetcode-cn.com/problems/find-leaves-of-binary-tree/)

```C++
//T,S:O(n)
//æ€è·¯ï¼šååºéå†ï¼Œæ·±åº¦ä»åº•å‘ä¸Šç®—,å¶å­ç»“ç‚¹çš„æ·±åº¦ä¸º0
class Solution {
public:
    vector<vector<int>> res;
    int dfs(TreeNode* root) { //depthä»0å¼€å§‹
        if (!root) return -1;	//è¿”å›-1,ä»0å¼€å§‹
        int left = dfs(root->left);
        int right = dfs(root->right);
        int depth = max(left, right) + 1;
        if (depth >= res.size()) res.push_back({});
        res[depth].push_back(root->val);
        return depth;
    }
    vector<vector<int>> findLeaves(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

#### [572. å¦ä¸€ä¸ªæ ‘çš„å­æ ‘](https://leetcode-cn.com/problems/subtree-of-another-tree/)

```C++
//T:O(s*t) S:O(max{s,t})  æ ‘çš„æ·±åº¦sï¼Œt
//æ€è·¯ï¼šè½¬åŒ–ä¸ºæ£€æŸ¥æ ¹ç»“ç‚¹ï¼Œå·¦å³å­æ ‘æ˜¯å¦ç›¸åŒ
class Solution {
public:
    bool isSame(TreeNode* root, TreeNode* subRoot){  //æ˜¯å¦ç›¸åŒ
        if(!root && !subRoot) return true;//âš ï¸
        if((!root && subRoot) || (root&&!subRoot) || root->val != subRoot->val) return false;
        return isSame(root->left,subRoot->left) && isSame(root->right, subRoot->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root == nullptr) return false;//âš ï¸
        return isSame(root,subRoot) || isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot);
    }   
};
```

#### [404. å·¦å¶å­ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```C++
/*T,S:O(n)
æ€è·¯ï¼šå…ˆåºéå†ï¼šres+=å·¦å­æ ‘çš„å·¦å¶å­ç»“ç‚¹çš„val
*/
class Solution {
public:
    int res=0;
    TreeNode* NLR(TreeNode* root){
        if(root == nullptr) return nullptr;
        TreeNode* l = NLR(root->left);
        TreeNode* r = NLR(root->right);
        if(l && l->left == nullptr && l->right ==nullptr) res+=l->val;
        return root;
    }
    int sumOfLeftLeaves(TreeNode* root) {
        NLR(root);
        return res;
    }
};
```

#### [513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```C++
/*å±‚æ¬¡éå†ï¼šæ¯æ¬¡ä¿å­˜ç¬¬ä¸€ä¸ªå€¼ res=cur
*/
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int res=0;
        while(!q.empty()){
            int s=q.size();
            for(int i=0;i<s;i++){
                auto node=q.front();q.pop();
                if(i==0) res = node->val;
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```

#### [538. æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```C++
/*æ€è·¯ï¼šååºä¸­åºéå†
*/
class Solution {
public:
    int sum=0;
    void  RNL(TreeNode* root){
        if(root == nullptr) return;
        RNL(root->right);
        sum += root->val;
        root->val = sum;
        RNL(root->left);
    }
    TreeNode* convertBST(TreeNode* root) {
        RNL(root);
        return root;
    }
};
```

#### [530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

```C++
/*T,S:O(n)
æ€è·¯ï¼šä¸­åºéå†ï¼Œpreï¼Œres
*/
class Solution {
public:
    void LNR(TreeNode* root,int &res,int &pre){//âš ï¸å¼•ç”¨
        if(root == nullptr) return;
        LNR(root->left,res,pre);
        if(pre == -1){
            pre = root->val;
        }else{
            res = min(res,root->val-pre);
            pre = root->val;
        }
        LNR(root->right,res,pre);
    }
    int getMinimumDifference(TreeNode* root) {
        int res=INT_MAX,pre=-1;
        LNR(root,res,pre);
        return res;
    }
};
```

#### [897. é€’å¢é¡ºåºæŸ¥æ‰¾æ ‘](https://leetcode-cn.com/problems/increasing-order-search-tree/)

```C++
/*ä¸­åºéå†ï¼šdummyNodeï¼Œä¸­é—´æ”¹å˜æŒ‡å‘
*/
class Solution {
private:
    TreeNode *resNode;
public:
    void inorder(TreeNode *node) {
        if (node == nullptr) return;
        inorder(node->left);
        resNode->right = node;
        node->left = nullptr;
        resNode = node;     //æ›´æ–°
        inorder(node->right);
    }

    TreeNode *increasingBST(TreeNode *root) {
        TreeNode *dummyNode = new TreeNode(-1);
        resNode = dummyNode;    //dummyNodeæš‚å­˜å¤´æŒ‡é’ˆ
        inorder(root);
        return dummyNode->right;
    }
};
```

#### [653. ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥ BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

```C++
/*å“ˆå¸Œè¡¨ set.count(target-root->val)
T,S:O(n)
*/
class Solution {
public:
    set<int> my_set;
    bool find(TreeNode* root,int k){
        if(root == nullptr) return false;
        if(my_set.count(k-root->val)) return true;
        my_set.insert(root->val);
        return find(root->left,k) || find(root->right,k);
    } 
    bool findTarget(TreeNode* root, int k) {
        return find(root,k);
    }
};
```

#### [450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

![image-20211125195244554](/Users/zcz/Desktop/images/image-20211125195244554.png)

```C++
/*
æ€è·¯ï¼š1.key>root.valï¼Œåˆ é™¤å³å­æ ‘2.<åˆ é™¤å·¦å­æ ‘ 3.ç›¸ç­‰ï¼Œrootä¸ºå¶å­ç»“ç‚¹ï¼Œæœ‰å³ç»“ç‚¹ï¼Œåªæœ‰å·¦ç»“ç‚¹*/
class Solution {
public:
    int successor(TreeNode* root) { //ä¸­åºéå†åºåˆ—çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚å³æ¯”å½“å‰èŠ‚ç‚¹å¤§çš„æœ€å°èŠ‚ç‚¹ï¼ˆåç»­ç»“ç‚¹ï¼‰
        root = root->right;
        while (root->left != nullptr) root = root->left;
        return root->val;
    }
    int predecessor(TreeNode* root) {//ä¸­åºéå†åºåˆ—çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚å³æ¯”å½“å‰èŠ‚ç‚¹å°çš„æœ€å¤§èŠ‚ç‚¹ï¼ˆå‰ç»­ç»“ç‚¹ï¼‰
        root = root->left;
        while (root->right != nullptr) root = root->right;
        return root->val;
    }

    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return nullptr;
        if (key > root->val) root->right = deleteNode(root->right, key);
        else if (key < root->val) root->left = deleteNode(root->left, key);
        else {
            if (root->left == nullptr && root->right == nullptr) root = nullptr;
            else if (root->right != nullptr) {
                root->val = successor(root);
                root->right = deleteNode(root->right, root->val);
            }
            else {
                root->val = predecessor(root);
                root->left = deleteNode(root->left, root->val);
            }
        }
        return root;
    }
};
```

#### [å‰‘æŒ‡ Offer 26. æ ‘çš„å­ç»“æ„](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```C++
/*è½¬åŒ–ä¸º
*/
class Solution {
public:
    bool isSame(TreeNode* root, TreeNode* subRoot){  //æ˜¯å¦ç›¸åŒ
        if(subRoot == NULL) return true;    //âš ï¸
        if((!root && subRoot) || (root&&!subRoot) || root->val != subRoot->val) return false;
        return isSame(root->left,subRoot->left) && isSame(root->right, subRoot->right);
    }
    bool isSubStructure(TreeNode* root, TreeNode* subRoot) {
        if(root == NULL || subRoot == NULL ) return false;//âš ï¸
        return isSame(root,subRoot) || isSubStructure(root->left,subRoot) || isSubStructure(root->right,subRoot);
    }
};
```

#### [å‰‘æŒ‡ Offer 64. æ±‚1+2+â€¦+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

```C++
/*
1.é€’å½’ï¼šé€»è¾‘&&   T,S:O(n)
2.
*/
class Solution {
public:
    int sumNums(int n) {
        n && (n += sumNums(n-1));//A && B,Aä¸ºfalseæ—¶ï¼Œåˆ™ä¸æ‰§è¡ŒB
        return n;
    }
};
```

#### [617.åˆå¹¶äºŒå‰æ ‘](https://leetcode-cn.com/problems/merge-two-binary-trees)

```C++
/*T,S:O(minâ¡(m,n))
æ€è·¯ï¼šå…ˆåºéå†
*/
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == nullptr) return t2;
        if (t2 == nullptr) return t1;
        auto merged = new TreeNode(t1->val + t2->val);
        merged->left = mergeTrees(t1->left, t2->left);
        merged->right = mergeTrees(t1->right, t2->right);
        return merged;
    }
};
```

#### [654.æœ€å¤§äºŒå‰æ ‘](https://leetcode-cn.com/problems/maximum-binary-tree)

```C++
/*å…ˆåºéå†ï¼šæ¯æ¬¡å–æœ€å¤§å€¼ä½œä¸ºæ ¹ç»“ç‚¹
T,S:O(n)
*/
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (!nums.size()) return nullptr;
        auto mid = max_element(nums.begin(), nums.end());// å¯»æ‰¾æœ€å¤§å€¼
        vector<int> l(nums.begin(), mid);           // æ„å»ºå·¦/å³éƒ¨åˆ†æ•°ç»„
        vector<int> r(mid + 1, nums.end());

        TreeNode* root = new TreeNode(*mid);        // é€’å½’çš„ä¼˜ç¾
        root -> left = constructMaximumBinaryTree(l);
        root -> right = constructMaximumBinaryTree(r);
        return root;
    }
};
```

#### [655.è¾“å‡ºäºŒå‰æ ‘](https://leetcode-cn.com/problems/print-binary-tree)

```C++
/*T,S:O(hâˆ—2^h)  hæ ‘çš„é«˜åº¦
æ€è·¯ï¼šå…ˆåºéå†+äºŒåˆ†
*/
class Solution {
public:
    vector<vector<string>> res;
    vector<vector<string>> printTree(TreeNode* root) {
        int m = height(root);
        int n = pow(2, m) -1;
        // äºŒç»´vectorä¸€è‡´å¡«å……å¥½
        for (int i=0; i<m; ++i){
            vector<string> temp;
            for (int i=0; i<n; ++i){
                temp.push_back("");
            }
            res.push_back(temp);
        }
        fill(root, 0, 0, n-1);
        return res;
    }

    void fill(TreeNode* root, int depth, int begin, int end){
        if (!root) return;
        int mid = begin + (end-begin)/2;
        res[depth][mid] = to_string(root->val);
        fill(root->left, depth+1, begin, mid-1);
        fill(root->right, depth+1, mid+1, end);
    }

    int height(TreeNode* root){
        if (!root) return 0;
        return max(height(root->left), height(root->right))+1;
    }
};
```



