---
title: 2.DFS/BFS+å›æº¯
date: 2021-1-2 21:55:00
tags: Algorithm
categories: ç®—æ³•
---

# 2.DFS/BFS+å›æº¯

> å›æº¯ï¼š
>
> DFSï¼š
>
> BFSï¼š

<!--more-->

### å›æº¯

```C++
æ¨¡æ¿
res = []
path = []
def backtrack(æœªæ¢ç´¢åŒºåŸŸ, res, path):
    if æœªæ¢ç´¢åŒºåŸŸæ»¡è¶³ç»“æŸæ¡ä»¶:
        res.add(path) # æ·±åº¦æ‹·è´
        return
    for é€‰æ‹© in æœªæ¢ç´¢åŒºåŸŸå½“å‰å¯èƒ½çš„é€‰æ‹©:
        if å½“å‰é€‰æ‹©ç¬¦åˆè¦æ±‚:
            path.add(ä½œå‡ºé€‰æ‹©)
            backtrack(æ–°çš„æœªæ¢ç´¢åŒºåŸŸ, res, path)
            path.pop()Â æ’¤é”€é€‰æ‹©
```

#### [131. åˆ†å‰²å›æ–‡ä¸²](https://leetcode-cn.com/problems/palindrome-partitioning/) ğŸ€„ï¸

```C++
/*T:O(Nâˆ—2^N)  S:O(2^N)
æ€è·¯ï¼šç»å…¸å›æº¯
*/
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        backTrack(s,res,{});
        return res;
    }
    void backTrack(string s,vector<vector<string>> &res,vector<string> path){
        if(s.size() == 0){              //ç©ºä¸²
            res.push_back(path);        //ç›´æ¥åŠ å…¥ç»“æœ
            return;
        } 
        for(int i=1;i<=s.size();i++){       //1.éå†æ‰€æœ‰å¯èƒ½,ä»1å¼€å§‹
            string pre=s.substr(0,i);       //å½“å‰å­ä¸²  æ²¡æœ‰å–åˆ°i
            if(check(pre)){                 //2.æ»¡è¶³
                path.push_back(pre);        //3.ä½œå‡ºé€‰æ‹© åŠ å…¥
                backTrack(s.substr(i),res,path);    //4.é€’å½’ å‰é¢çš„i-1å·²ç»åŒ¹é…ï¼Œç°ä»iå–åˆ°ç»“å°¾
                path.pop_back();        //5.å›æº¯
            }
        }
    }
    bool check(string s){
        int st=0,ed=s.size()-1;
        while(st <= ed){
            if(s[st] != s[ed]) return false;
            st++;ed--;
        }
        return true;
    }
};
```



#### [39. ç»„åˆæ€»å’Œ](https://leetcode-cn.com/problems/combination-sum/)

```C++
//T:O(S) Så¯è¡Œè§£çš„é•¿åº¦  S:O(target)
class Solution {
public:
    vector<vector<int>> res;
    vector<int> output;
    void backTrace(vector<int>& candidates,int x,int len,int target){
        if(target < 0) return;
        if(target == 0) {res.emplace_back(output);return;}
        for(int i=x; i<len;i++){
            output.emplace_back(candidates[i]);             //é€‰æ‹©
            backTrace(candidates, i, len, target - candidates[i]);//é€’å½’,iâš ï¸å½“å‰æ•°å¯ä»¥é‡å¤é€‰æ‹©
            output.pop_back();                              //æ’¤é”€é€‰æ‹©
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        int len =candidates.size();
        if(len == 0) return res;
        backTrace(candidates,0,len,target);
        return res;
    }
};
```

#### [40. ç»„åˆæ€»å’Œ II](https://leetcode-cn.com/problems/combination-sum-ii/)

```C++
//æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚
//T:O(S) Så¯è¡Œè§£çš„é•¿åº¦  S:O(target)
class Solution {
public:
    vector<vector<int>> res;
    vector<int> output;
    void dfs(vector<int>& candidates,int x,int len,int target){
        if(target < 0) return;
        if(target == 0) {res.emplace_back(output);return;}
        for(int i=x; i<len;i++){
            if(i>x && candidates[i] == candidates[i-1]) continue;	//å‰ªæ
            output.emplace_back(candidates[i]);             //é€‰æ‹©
            dfs(candidates, i+1, len, target - candidates[i]);//é€’å½’ï¼Œi+1
            output.pop_back();                              //æ’¤é”€é€‰æ‹©
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        int len =candidates.size();
        if(len == 0) return res;
        sort(candidates.begin(),candidates.end());	//ä¸ºäº†å»é‡
        dfs(candidates,0,len,target);
        return res;
    }
};
```

#### [216. ç»„åˆæ€»å’Œ III](https://leetcode-cn.com/problems/combination-sum-iii/)

![image-20211126202127765](2.BFS_DFS_å›æº¯/image-20211126202127765.png)

```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> output;
    void backTrace(int x,int sum,int k,int target){
        if(sum == target && output.size() == k) {
            res.push_back(output);
            return;
        }
        for(int i=x;i<=(9 > (target-sum-(k-output.size()-1)*(k-output.size())/2)?(target-sum-(k-output.size()-1)*(k-output.size())/2):9);i++){ //å‰ªæ
            sum += i;
            output.push_back(i);
            backTrace(i+1,sum,k,target);
            output.pop_back();
            sum -= i;
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        if(k > n) return res;
        backTrace(1,0,k,n);
        return res;
    }
};
```

#### [78. å­é›†](https://leetcode-cn.com/problems/subsets/)

```C++
//T:O(n*2^n) S:O(n) 
//
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTrace(int x,int len,vector<int>& nums){
        res.push_back(path);
        for(int i=x;i<len;i++){
            path.push_back(nums[i]);
            backTrace(i+1,len,nums);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        int len =nums.size();
        if(len ==0) return res;
        backTrace(0,len,nums);
        return res;
    }
};
```

#### [90. å­é›† II](https://leetcode-cn.com/problems/subsets-ii/)

```C++
//åŸé›†åˆnumsåŒ…å«é‡å¤å…ƒç´ 
//T:O(n*2^n) S:O(n)
class Solution {
public:
    vector<vector<int>> res;
    void backtrack(vector<int>nums,vector<int>&path,int start)
    {
        res.push_back(path);
        for(int i=start;i<nums.size();i++)
        {
            if(i > start && nums[i] == nums[i-1]) continue;//å‰ªæï¼Œå»é‡âš ï¸
            path.push_back(nums[i]);//åšå‡ºé€‰æ‹©
            backtrack(nums,path,i+1);//é€’å½’è¿›å…¥ä¸‹ä¸€å±‚ï¼Œæ³¨æ„i+1ï¼Œæ ‡è¯†ä¸‹ä¸€ä¸ªé€‰æ‹©åˆ—è¡¨çš„å¼€å§‹ä½ç½®ï¼Œæœ€é‡è¦çš„ä¸€æ­¥
            path.pop_back();//æ’¤é”€é€‰æ‹©
        }
    }

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<int> path;
        sort(nums.begin(),nums.end());  //ä¸ºäº†å»é‡âš ï¸
        backtrack(nums,path,0);
        return res;
    }
};
```

#### [77. ç»„åˆ](https://leetcode-cn.com/problems/combinations/)

```

```



#### [46. å…¨æ’åˆ—](https://leetcode-cn.com/problems/permutations/)

```C++
//T:O(n*n!) S:O(n)
//numsä¸é‡å¤
class Solution {
public:
    vector<vector<int>> res;
    vector<int> vis;
    void backtrack(vector<int>& nums,int x,int len,vector<int> &perm){
        if(x == len){
            res.emplace_back(perm);
            return;
        }

        for(int i=0;i<len;i++){	//âš ï¸ä»0å¼€å§‹å›ºå®šé•¿åº¦len
            if (vis[i]) {//ä¸é‡å¤ï¼æ²¡æœ‰è®¿é—®è¿‡
                continue;
            }
            vis[i] = 1;
            perm.emplace_back(nums[i]);//ä½œå‡ºé€‰æ‹©
            backtrack(nums,x+1,len,perm);  //âš ï¸é€’å½’
            vis[i]=0;
            perm.pop_back(); //æ’¤é”€é€‰æ‹©
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vis.resize(nums.size());
        vector<int> perm;
        //sort(nums.begin(), nums.end());
        backtrack(nums,0,nums.size(),perm);
        return res;
    }
};
```

#### [47. å…¨æ’åˆ— II](https://leetcode-cn.com/problems/permutations-ii/)

```C++
//T:O(n*n!) S:O(n)
//numsé‡å¤æ•°å­—  
class Solution {
public:
    vector<vector<int>> res;
    vector<int> vis;
    void backtrack(vector<int>& nums,int x,int len,vector<int> &perm){
        if(x == len){
            res.emplace_back(perm);
            return;
        }

        for(int i=0;i<len;i++){
            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {//æ²¡æœ‰è®¿é—®è¿‡ ä¸é‡å¤
                continue;
            }
            vis[i] = 1;
            perm.emplace_back(nums[i]);//ä½œå‡ºé€‰æ‹©
            backtrack(nums,x+1,len,perm);  //é€’å½’
            vis[i]=0;
            perm.pop_back(); //æ’¤é”€é€‰æ‹©
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vis.resize(nums.size());
        vector<int> perm;
        sort(nums.begin(), nums.end());
        backtrack(nums,0,nums.size(),perm);
        return res;
    }
};
```

#### [å‰‘æŒ‡ Offer 38. å­—ç¬¦ä¸²çš„æ’åˆ—](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

```C++
//T:O(n*n!) S:O(n)
//sæœ‰é‡å¤ åŒä¸Š
class Solution {
public:
    vector<string> res;
    vector<int> vis;
    void backtrack(string &s,int x,int len,string &path){
        if(x == len){
            res.push_back(path);
            return;
        }

        for(int i=0;i<len;i++){
            if (vis[i] || (i > 0 && s[i] == s[i - 1] && !vis[i - 1])) {//ä¸é‡å¤ï¼æ²¡æœ‰è®¿é—®è¿‡
                continue;
            }
            vis[i] = 1;
            path.push_back(s[i]);//ä½œå‡ºé€‰æ‹©
            backtrack(s,x+1,len,path);  //é€’å½’
            vis[i]=0;
            path.pop_back(); //æ’¤é”€é€‰æ‹©
        }
    }
    vector<string> permutation(string s) {
        vis.resize(s.size());
        string path;
        sort(s.begin(), s.end());
        backtrack(s,0,s.size(),path);
        return res;
    }
};
```

#### [784. å­—æ¯å¤§å°å†™å…¨æ’åˆ—](https://leetcode-cn.com/problems/letter-case-permutation/)

```C++
//A-Z 65-90 a-z 97-122  0-9 48-57
//æœç´¢ T,S:O(N*2^N)   Nå­—ç¬¦ä¸²é•¿åº¦
class Solution {
public:
    vector<string> res;
    void backTrace(int x,string& s){
        if(x == s.length()){
            res.push_back(s);
            return;
        }
        if(isdigit(s[x])){	//æ•°å­—ç›´æ¥å›æº¯
            backTrace(x+1,s);
        }else{
            s[x] = tolower(s[x]);	//å›æº¯å°å†™
            backTrace(x+1,s);
            s[x] = toupper(s[x]);//å›æº¯å¤§å†™
            backTrace(x+1,s);
        }
    }
    vector<string> letterCasePermutation(string s) {
        backTrace(0,s);
        return res;
    }
};
```



#### [å‰‘æŒ‡ Offer 17. æ‰“å°ä»1åˆ°æœ€å¤§çš„nä½æ•°](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

```C++
//é€’å½’å…¨æ’åˆ—
//Tï¼šO(10^n) S:O(10^n)
class Solution {
    vector<string> res;
    string cur;
    char NUM[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    
    // ç”Ÿæˆé•¿åº¦ä¸º len çš„æ•°å­—ï¼Œæ­£åœ¨ç¡®å®šç¬¬xä½ï¼ˆä»å·¦å¾€å³ï¼‰
    void backtrack(int x, int len) {
        if(x == len) {
            res.push_back(cur);
            return;
        }
        int start = x==0? 1 : 0; // X=0è¡¨ç¤ºå·¦è¾¹ç¬¬ä¸€ä½æ•°å­—ï¼Œä¸èƒ½ä¸º0
        for(int i=start; i<10; i++) {
            cur.push_back(NUM[i]); // ç¡®å®šæœ¬ä½æ•°å­—
            backtrack(x+1, len); // ç¡®å®šä¸‹ä¸€ä½æ•°å­—
            cur.pop_back(); // åˆ é™¤æœ¬ä½æ•°å­—
        }
    }
public:
    vector<int> printNumbers(int n) {
        for(int i=1; i<=n; i++) // æ•°å­—é•¿åº¦ï¼š1~n
            backtrack(0, i);

        vector<int> res_int;
        for(int i=0; i<res.size(); i++)
            res_int.push_back(stoi(res[i]));
        return res_int;
    }
};
```

#### [140. å•è¯æ‹†åˆ† II](https://leetcode-cn.com/problems/word-break-ii/)

```C++
//è®°å¿†åŒ–æœç´¢
//ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨å­—ç¬¦ä¸² s çš„æ¯ä¸ªä¸‹æ ‡å’Œä»è¯¥ä¸‹æ ‡å¼€å§‹çš„éƒ¨åˆ†å¯ä»¥ç»„æˆçš„å¥å­åˆ—è¡¨ï¼Œ
//åœ¨å›æº¯è¿‡ç¨‹ä¸­å¦‚æœé‡åˆ°å·²ç»è®¿é—®è¿‡çš„ä¸‹æ ‡ï¼Œåˆ™å¯ä»¥ç›´æ¥ä»å“ˆå¸Œè¡¨å¾—åˆ°ç»“æœï¼Œè€Œä¸éœ€è¦é‡å¤è®¡ç®—ã€‚
//T,S:O(n*2^n)
class Solution {
private:
    unordered_map<int, vector<string>> res;
    unordered_set<string> wordSet;  //å“ˆå¸Œè¡¨ï¼ŒåŠ å¿«

public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        wordSet = unordered_set(wordDict.begin(), wordDict.end());
        backtrack(s, 0);
        return res[0];
    }

    void backtrack(const string& s, int x) {
        if (!res.count(x)) {        //æ²¡æœ‰å­˜è¿‡ï¼Œè¿›å…¥
            if (x == s.size()) {    
                res[x] = {""};      //å­—ç¬¦ä¸²æœ«å°¾
                return;
            }
            res[x] = {};
          //ç”±äºsubstrï¼Œå› æ­¤i <= s.size()âš ï¸
            for (int i = x + 1; i <= s.size(); ++i) {
                string word = s.substr(x, i - x);   //ä»xå¼€å§‹ï¼Œæˆªå–i-xä¸ª
                if (wordSet.count(word)) {  //å½“å‰è¯æ˜¯å¦åœ¨è¯å…¸ä¸­
                    backtrack(s, i);        //iå¯é‡å¤
                    for (const string& succ: res[i]) {
                        res[x].push_back(succ.empty() ? word : word + " " + succ);
                    }
                }
            }
        }
    }
};
```





#### [267.å›æ–‡æ’åˆ—  II](https://leetcode-cn.com/problems/palindrome-permutation-ii/)

```

```

#### [401. äºŒè¿›åˆ¶æ‰‹è¡¨](https://leetcode-cn.com/problems/binary-watch/)

```C++
class Solution {
public:
    int hours[10] = {1,2,4,8,0,0,0,0,0,0};  //ä»10ä¸ªé€‰numä¸ª
    int mins[10] = {0,0,0,0,1,2,4,8,16,32};
    vector<string> res;
    void backTrace(int num,int x,int h,int m){
        if(h > 11 | m >59) return;  //ä¸ç¬¦åˆ
        if(num == 0){   //æ²¡æœ‰æŒ‡ç¤ºç¯äº†
            char tmp[6];    //æ³¨æ„è¿™é‡Œè¦å­—ç¬¦æ•°ç»„ï¼Œä¸èƒ½æ˜¯ string
            sprintf(tmp,"%d:%02d",h,m);
            res.push_back(tmp);
            return;
        }
        for(int i=x;i<10;i++){
            backTrace(num-1,i+1,h+hours[i],m+mins[i]);
        }

    }
    vector<string> readBinaryWatch(int num) {
        backTrace(num,0,0,0);
        return res;
    }
};
```

#### [17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```

```

#### [491. é€’å¢å­åºåˆ—](https://leetcode-cn.com/problems/increasing-subsequences/)

```

```

#### [22. æ‹¬å·ç”Ÿæˆ](https://leetcode-cn.com/problems/generate-parentheses/)

```

```



### DFS

#### [200. å²›å±¿æ•°é‡](https://leetcode-cn.com/problems/number-of-islands/) ğŸ€„ï¸

```C++
/*å›¾DFS
æ€è·¯ï¼šéå†æ•´ä¸ªåœ°å›¾çš„1ï¼Œè®°å¾—éå†è¿‡çš„1èµ‹å€¼ä¸º0ï¼Œè¿™æ ·å°±ä¸ä¼šé‡å¤è®¿é—®
*/
class Solution {
public:
    int row=0,col=0;
    int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};    //4ä¸ªæ–¹å‘
    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        row = grid.size();
        col = grid[0].size();
        for(int i=0;i<row;i++)  //éå†æ‰€æœ‰ç‚¹
            for(int j=0;j<col;j++)
                if(grid[i][j] == '1'){  //ç¬¦åˆæ¡ä»¶ï¼šdfs
                    res ++;
                    dfs(grid,i,j);
                }
        return res;
    }
    void dfs(vector<vector<char>>& grid,int i,int j){
      if(i < 0 || i >= row|| j<0 ||j >= col || grid[i][j] == '0') return;
        grid[i][j] = '0';       //éå†è¿‡äº†
        for(auto d:dir){				//éå†4ä¸ªæ–¹å‘
            int x = i + d[0], y = j+ d[1];	
            dfs(grid,x,y);			 //æ²¡æœ‰è¶Šç•Œ dfs
        }
    }
};
```

#### [695. å²›å±¿çš„æœ€å¤§é¢ç§¯](https://leetcode-cn.com/problems/max-area-of-island/)

```C++
//T,S:O(ROW*COl)
//
class Solution {
public:
    int dirs[4][2] ={{1,0},{0,1},{0,-1},{-1,0}};
    int dfs(vector<vector<int>>& grid,int i,int j){
        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() ||grid[i][j] != 1)//æå‰è¿”å›
            return 0;
        grid[i][j] = 0;
        int res=1;	//å½“å‰
        for(auto d:dirs){
            int x=i+d[0],y=j+d[1];
            res += dfs(grid,x,y);
        }
        return res;
    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int res = 0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                res = max(res,dfs(grid,i,j)); //å–æœ€å¤§çš„
            }
        }
        return res;
    }
};
```

#### [463. å²›å±¿çš„å‘¨é•¿](https://leetcode-cn.com/problems/island-perimeter/)

```C++
//DFS. T,S:O(nm)
class Solution {
public:
    int dirs[4][2] ={{0,1},{1,0},{0,-1},{-1,0}};
    int dfs(vector<vector<int>> &grid,int i,int j){
        if(i <0 || i >= grid.size() || j <0 || j>=grid[0].size() || grid[i][j] == 0) return 1;
        if(grid[i][j] == 2) return 0;   //éå†è¿‡äº†
        grid[i][j] = 2;
        int ans = 0;
        for(auto d:dirs){   
            int x=d[0]+i,y=d[1]+j;
            ans += dfs(grid,x,y);   //ä¸ç”¨å†åˆ¤æ–­ grid[i][j] == 1
        }
        return ans;
    }

    int islandPerimeter(vector<vector<int>> &grid) {
        int m = grid.size(), n = grid[0].size();
        int res=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j] == 1){
                    res += dfs(grid,i,j);
                  	//res = max(res, dfs(grid,i,j));æœ€å¤§å‘¨é•¿
                }
            }
        }
        return res;
    }
};
```

#### [827. æœ€å¤§äººå·¥å²›](https://leetcode-cn.com/problems/making-a-large-island/)

![image-20211212102721764](2.BFS_DFS_å›æº¯/image-20211212102721764.png)

```C++
/*ç›´æ¥æ·±æœï¼šTï¼šO(n^4)ï¼Œè¶…æ—¶
å¯¹äºæ¯ä¸ª 0ï¼Œå°†å®ƒå˜æˆ 1ï¼Œç„¶ååšä¸€æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢è®¡ç®—å‡ºè¿é€šå—çš„å¤§å°ã€‚ç­”æ¡ˆå°±æ˜¯æ‰¾åˆ°çš„æœ€å¤§è¿é€šå—ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡è®°å½•è¿é€šå—ç¼–å·æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸åŒçš„è¿é€šå—ç¼–å·ä¸åŒã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç´¯åŠ ä¸åŒç¼–å·çš„è¿é€šå—é¢ç§¯å’Œã€‚
T,Sï¼šO(n^2)ï¼Œ
*/

```

#### [547. çœä»½æ•°é‡](https://leetcode-cn.com/problems/number-of-provinces/)

```C++
//æ— å‘å›¾çš„è¿é€šæ•°,T:O(n^2),S:O(n)
class Solution {
public:
    void dfs(vector<vector<int>>& isConnected,vector<int> &visited,int n,int i){
      	visited[i] = true;		//æ ‡è®°å½“å‰ç»“ç‚¹éå†è¿‡
        for(int j=0;j<n;j++){   //éå†ä¸‹ä¸€ä¸ªj
            if(isConnected[i][j] == 1 && !visited[j]){//å½“å‰æ˜¯1ï¼Œå¹¶ä¸”æ²¡æœ‰è®¿é—®è¿‡
                dfs(isConnected,visited,n,j);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& isConnected) {
        int res=0;
        int n = isConnected.size();
        vector<bool> visited(n,false);
        for(int i=0;i<n;i++){   //éå†i
            if(!visited[i]){    //æ³¨æ„æ²¡æœ‰è®¿é—®è¿‡
              	res++;
                dfs(isConnected,visited,n,i);
            }
        }
        return res;
    }
};
```

#### [841. é’¥åŒ™å’Œæˆ¿é—´](https://leetcode-cn.com/problems/keys-and-rooms/)

```C++
//T:O(n+m) S:O(n)  n æ˜¯æˆ¿é—´çš„æ•°é‡ï¼Œm æ˜¯æ‰€æœ‰æˆ¿é—´ä¸­çš„é’¥åŒ™æ•°é‡çš„æ€»æ•°ã€‚
class Solution {
public:
    int res=0;
    void dfs(vector<bool> &visited,vector<vector<int>>& rooms,int x){
        if(visited[x]) return;
        visited[x] = true;
        res++;
        for(auto &it:rooms[x]){ //éå†å½“å‰room[x]çš„æ‰€æœ‰é’¥åŒ™
            dfs(visited,rooms,it);
        }
    }
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n=rooms.size();
        vector<bool> visited(n);
        dfs(visited,rooms,0);
        return res == n;
    }
};
```

#### [å‰‘æŒ‡ Offer 13. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```C++
//T,S:O(mn)
//å‘ä¸‹ï¼Œå³éå†ï¼šsiï¼Œsj iï¼Œjå„è‡ªçš„å’Œã€‚
//siç­‰äº9æ—¶,é€’å½’si+1ï¼Œæ­¤æ—¶si=10,å’Œä¸º1ï¼Œå› æ­¤si-8=1ï¼Œå’Œä¹Ÿä¸º1
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<bool>> visited(m, vector<bool>(n, 0));
        return dfs(0, 0, 0, 0, visited, m, n, k);
    }
private:
    int dfs(int i, int j, int si, int sj, vector<vector<bool>> &visited, int m, int n, int k) { //å‰ªæ
        if(i >= m || j >= n || k < si + sj || visited[i][j]) return 0;
        visited[i][j] = true;
        return 1 + dfs(i + 1, j, (i + 1) % 10 != 0 ? si + 1 : si - 8, sj, visited, m, n, k) +
                   dfs(i, j + 1, si, (j + 1) % 10 != 0 ? sj + 1 : sj - 8, visited, m, n, k);
    }
};
```

#### [é¢è¯•é¢˜ 08.02. è¿·è·¯çš„æœºå™¨äºº](https://leetcode.cn/problems/robot-in-a-grid-lcci/)

`java`

```java
class Solution {
    boolean res = false;
    List<List<Integer>> ans = new ArrayList<>();
    void dfs(int[][] grid,int i,int j,int m,int n){
        if(i < 0 || i>=m || j<0 || j>=n || grid[i][j] == 1  || res) return;
        grid[i][j] = 1;
        if(i == m-1 && j == n-1){
            res = true;
            ans.add(Arrays.asList(i, j));
            return;
        }
        ans.add(Arrays.asList(i, j));
        dfs(grid,i,j+1,m,n);
        dfs(grid,i+1,j,m,n);
        if(!res) ans.remove(ans.size()-1);
    }
    public List<List<Integer>> pathWithObstacles(int[][] grid) {
        int m=grid.length,n=grid[0].length;
        dfs(grid,0,0,m,n);
        if(res) return ans;
        else return new ArrayList<>();
    }
}
```

#### [130. è¢«å›´ç»•çš„åŒºåŸŸ](https://leetcode-cn.com/problems/surrounded-regions/)

![image-20210929200631155](2.BFS_DFS_å›æº¯/image-20210929200631155.png)

```C++
//T,S:O(m*n)
class Solution {
public:
    int n, m;
	int dirs[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};
    void dfs(vector<vector<char>>& board, int x, int y) {
        if(x < 0 || x >= n || y < 0 || y >= m || board[x][y] != 'O') return;
        board[x][y] = 'A';	//éå†è¿‡çš„èµ‹å€¼
      	for(auto d:dirs){
            int tx=x+d[0],ty=y+d[1];
            dfs(board,tx,ty);
        }
    }

    void solve(vector<vector<char>>& board) {
        n = board.size();
        if (n == 0) {
            return;
        }
        m = board[0].size();
        //Â éå†è¾¹ç•Œ
        for (int i = 0; i < n; i++) dfs(board,i,0),dfs(board, i, m - 1);
        for (int i = 1; i < m - 1; i++) dfs(board, 0, i),dfs(board, n - 1, i);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'A') { //æ ‡å¿—äº†ï¼Œæ¢å¤äº†O
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }
};
```

#### [417. å¤ªå¹³æ´‹å¤§è¥¿æ´‹æ°´æµé—®é¢˜](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

```C++
//é€†æµè€Œä¸Šã€‚Tï¼ŒSï¼šO(m*n)
//å¯¹äºä¸€ä¸ªç‚¹å®ƒèƒ½æµåŠ¨ä¸¤è¾¹çš„å¤§æ´‹ï¼Œé‚£ä¹ˆåè¿‡æ¥ï¼Œä¸¤è¾¹å¤§æ´‹çš„æ°´åç€æµå°±èƒ½è¾¾åˆ°è¿™ä¸ªç‚¹ã€‚
class Solution {
public:
    vector<vector<int>> P, A, ans;
    int n, m;
    int dirs[4][2]={{1,0},{0,1},{0,-1},{-1,0}};
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {
        n = M.size(), m = M[0].size();
        P = A = vector<vector<int>>(n, vector<int>(m, 0));
        //å·¦å³ä¸¤è¾¹åŠ ä¸Šä¸‹ä¸¤è¾¹å‡ºå‘æ·±æœ âš ï¸
        for(int i = 0; i < n; ++i) dfs(M, P, i, 0), dfs(M, A, i, m - 1);
        for(int j = 0; j < m; ++j) dfs(M, P, 0, j), dfs(M, A, n - 1, j);             
        return ans;
    }
    void dfs(vector<vector<int>>& M, vector<vector<int>>& visited, int i, int j){        
        if(visited[i][j]) return;
        visited[i][j] = 1;
        if(P[i][j] && A[i][j]) ans.push_back({i,j}); 
        for(auto d:dirs){
            int x = i+d[0],y=j+d[1];
            if(x < 0 || x >= n || y <0 || y>=m || M[x][y] < M[i][j]) continue; 
            dfs(M, visited, x,y);
        }
    }
};

```

#### [332. é‡æ–°å®‰æ’è¡Œç¨‹](https://leetcode-cn.com/problems/reconstruct-itinerary/)

```C++
/*å›¾DFS
æ¬§æ‹‰è·¯å¾„ï¼šèƒ½å¦ä¸èµ°é‡å¤çš„è·¯è€Œéå†ä¸€ä¸ªå›¾çš„æ‰€æœ‰è¾¹ã€‚
Hierholzer ç®—æ³•ç”¨äºåœ¨è¿é€šå›¾ä¸­å¯»æ‰¾æ¬§æ‹‰è·¯å¾„ï¼Œå…¶æµç¨‹å¦‚ä¸‹ï¼š
  ä»èµ·ç‚¹å‡ºå‘ï¼Œè¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ã€‚
  æ¯æ¬¡æ²¿ç€æŸæ¡è¾¹ä»æŸä¸ªé¡¶ç‚¹ç§»åŠ¨åˆ°å¦å¤–ä¸€ä¸ªé¡¶ç‚¹çš„æ—¶å€™ï¼Œéƒ½éœ€è¦åˆ é™¤è¿™æ¡è¾¹ã€‚
  å¦‚æœæ²¡æœ‰å¯ç§»åŠ¨çš„è·¯å¾„ï¼Œåˆ™å°†æ‰€åœ¨èŠ‚ç‚¹åŠ å…¥åˆ°æ ˆä¸­ï¼Œå¹¶è¿”å›ã€‚
*/
class Solution {
public:
    unordered_map<string,priority_queue<string,vector<string>,greater<string>>> map;    //å“ˆå¸Œè¡¨<string,å°æ ¹å †>
    vector<string> res;     //ç»“æœé›†
    void dfs(string cur){
        while(map.count(cur) && map[cur].size() > 0){    //éå†å½“å‰ç»“ç‚¹çš„æ‰€æœ‰ä¸‹ä¸€ä¸ªç»“ç‚¹
            string tmp = map[cur].top();    //å–å‡ºä¸‹ä¸€ä¸ªç»“ç‚¹
            map[cur].pop();                 //åˆ é™¤
            dfs(tmp);                       //ä»¥ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼šdfs
        } 
        res.emplace_back(cur);              //å°†å½“å‰ç»“ç‚¹åŠ å…¥ç»“æœé›†ä¸­
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for(auto &tk:tickets) map[tk[0]].push(tk[1]); //åˆå§‹åŒ–
        dfs("JFK");
        reverse(res.begin(),res.end());	//ç”±äºé€’å½’ï¼Œç»“æœé›†éœ€è¦åè½¬
        return res;
    }
};
```

#### [785. åˆ¤æ–­äºŒåˆ†å›¾](https://leetcode-cn.com/problems/is-graph-bipartite/)

![image-20210929190037482](2.BFS_DFS_å›æº¯/image-20210929190037482.png)

```C++
/*T:O(m+n) S:O(n)
äºŒåˆ†å›¾ å®šä¹‰ï¼šå¦‚æœèƒ½å°†ä¸€ä¸ªå›¾çš„èŠ‚ç‚¹é›†åˆåˆ†å‰²æˆä¸¤ä¸ªç‹¬ç«‹çš„å­é›† A å’Œ B ï¼Œå¹¶ä½¿å›¾ä¸­çš„æ¯ä¸€æ¡è¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¸€ä¸ªæ¥è‡ª A é›†åˆï¼Œä¸€ä¸ªæ¥è‡ª B é›†åˆï¼Œå°±å°†è¿™ä¸ªå›¾ç§°ä¸º äºŒåˆ†å›¾ ã€‚(è½¬åŒ–ä¸ºå›¾ç€è‰²é—®é¢˜ï¼šè¿æ¥çš„2ç‚¹ç€è‰²ä¸åŒ)
è¾“å…¥ï¼šgraph = [[1,3],[0,2],[1,3],[0,2]]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šå¯ä»¥å°†èŠ‚ç‚¹åˆ†æˆä¸¤ç»„: {0, 2} å’Œ {1, 3} ã€‚
*/
class Solution {
private:
    static constexpr int UNCOLORED = 0;
    static constexpr int RED = 1;
    static constexpr int GREEN = 2;
    bool valid;
public:
    void dfs(int node, int c, const vector<vector<int>>& graph,vector<int>& color) {
        color[node] = c;//u
        int next = (c == RED ? GREEN : RED);
        for (int neighbor: graph[node]) {
            if (color[neighbor] == UNCOLORED) {  //æœªæŸ“è‰²
                dfs(neighbor, next, graph,color);
                if (!valid) {   //æå‰é€€å‡º
                    return;
                }
            }
            else if (color[neighbor] != next) { //å½“å‰èŠ‚ç‚¹ä¸æ˜¯è®¾å®šå¥½next
                valid = false;
                return;
            }
        }
    }

    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> color(n,UNCOLORED);
        valid = true;
        for (int i = 0; i < n && valid; ++i) {
            if (color[i] == UNCOLORED) {    //æœªæŸ“è‰²
                dfs(i, RED, graph,color);
            }
        }
        return valid;
    }
};

```

#### [60. æ’åˆ—åºåˆ—](https://leetcode-cn.com/problems/permutation-sequence/) ç¬¬kä¸ªæ’åˆ—

```C++
//T:O(N^2) S:O(N) 
//æ€è·¯ï¼šå‰ªæï¼ˆå·²è®¿é—®ï¼Œk>å¶å­ç»“ç‚¹æ•°ï¼‰+DFS
class Solution {
public:
    string res;
    vector<int> f;
    vector<bool> vis;
    void dfs(int n,int k,int x){
        if(x == n) return;
        int cnt = f[n-1-x]; //å¶å­ç»“ç‚¹ä¸ªæ•°
        for(int i=1;i<=n;i++){
            if(vis[i]) continue;    //ï¼ˆ1ï¼‰å‰ªæ
            if(k > cnt) { k -= cnt;continue;}   //ï¼ˆ2ï¼‰å‰ªæ
            res += to_string(i);
            vis[i] = true;
            dfs(n,k,x+1);
            //ä¸å›æº¯ï¼Œæ²¡æœ‰å›å¤´çš„è¿‡ç¨‹
            return; //åé¢çš„æ•°æ²¡æœ‰å¿…è¦éå†å»å°è¯•äº†
        }
    }
    string getPermutation(int n, int k) {
        vis = vector<bool>(n,false);
        f = vector<int>(n+1,1);
        for(int i=1;i<=n;i++) f[i] = f[i-1]*i;
        dfs(n,k,0);
        return res;
    }
};
```

#### [254.å› å­çš„ç»„åˆ](https://leetcode-cn.com/problems/factor-combinations/)

![image-20211211110937828](2.BFS_DFS_å›æº¯/image-20211211110937828.png)

```C++
//DFS+å‰ªæ
class Solution {
public:
    vector<vector<int>> dfs(int x,int n){
        if(x == 1) return {};
        vector<vector<int>> res;
        int end = int(sqrt(n));         //(1)å‰ªæç‚¹ï¼Œéå†ç»ˆç‚¹
        for(int i=x;i<=end;i++){
            if(n%i == 0){           
                res.push_back({i,n/i});
                vector<vector<int>> next = dfs(i,n/i);  //(2)å‰ªæç‚¹,ä»iï¼Œä¸ä»1å¼€å§‹ï¼Œé¿å…é‡å¤
                for(auto& sub:next){
                    sub.push_back(i);
                    res.push_back(sub);
                }
            }
        }
        return res;
    }
    vector<vector<int>> getFactors(int n) {
        return dfs(2,n);
};
```



#### [207. è¯¾ç¨‹è¡¨](https://leetcode-cn.com/problems/course-schedule/)

```

```

#### [210. è¯¾ç¨‹è¡¨ II](https://leetcode-cn.com/problems/course-schedule-ii/)

```

```

#### [630. è¯¾ç¨‹è¡¨ III](https://leetcode-cn.com/problems/course-schedule-iii/)

```

```



#### [329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

```

```

#### [444. åºåˆ—é‡å»º](https://leetcode-cn.com/problems/sequence-reconstruction/)

```

```

#### [399. é™¤æ³•æ±‚å€¼](https://leetcode-cn.com/problems/evaluate-division/)

```C++
/*å›¾DFS

*/
```



#### [652. å¯»æ‰¾é‡å¤çš„å­æ ‘](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

```

```

#### [LCP 07. ä¼ é€’ä¿¡æ¯](https://leetcode-cn.com/problems/chuan-di-xin-xi/)

```C++
class Solution {
public:
    int numWays(int n, vector<vector<int>> &relation, int k) {
        vector<vector<int>> edges(n); //åˆ—è¡¨å­˜å‚¨è¾¹
        for (auto &edge : relation) {
            int src = edge[0], dst = edge[1];
            edges[src].push_back(dst);
        }
        int ways = 0;
        function<void(int, int)> dfs = [&](int index, int steps) { //åŒ¿åå‡½æ•°
            if (steps == k && index == n - 1)) {
                ++ways;
                return;
            }
            for (int to : edges[index]) 
                dfs(to, steps + 1);
        };
        dfs(0, 0);
        return ways;
    }
};
```



#### [733. å›¾åƒæ¸²æŸ“](https://leetcode-cn.com/problems/flood-fill/)

```C++
class Solution {
public:
    const int dx[4] = {1, 0, 0, -1};
    const int dy[4] = {0, 1, -1, 0};
    void dfs(vector<vector<int>>& image, int x, int y, int color, int newColor) {
        if (x < 0 || x >= image.size() || y < 0 || y >= image[0].size() || image[x][y] != color )return;
        image[x][y] = newColor;
        for (int i = 0; i < 4; i++) {
            int mx = x + dx[i], my = y + dy[i];
            dfs(image, mx, my, color, newColor);
        }
        
    }

    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int currColor = image[sr][sc];
        if (currColor != newColor) {
            dfs(image, sr, sc, currColor, newColor);
        }
        return image;
    }
};
```

ã€ŒåŠ›æ‰£ã€ç¬¬ 684 é¢˜ï¼š[å†—ä½™è¿æ¥](https://leetcode-cn.com/problems/redundant-connection)ï¼ˆä¸­ç­‰ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 1319 é¢˜ï¼š[è¿é€šç½‘ç»œçš„æ“ä½œæ¬¡æ•°](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected)ï¼ˆä¸­ç­‰ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 1631 é¢˜ï¼š[æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„](https://leetcode-cn.com/problems/path-with-minimum-effort)ï¼ˆä¸­ç­‰ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 959 é¢˜ï¼š[ç”±æ–œæ åˆ’åˆ†åŒºåŸŸ](https://leetcode-cn.com/problems/regions-cut-by-slashes)ï¼ˆä¸­ç­‰ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 1202 é¢˜ï¼š[äº¤æ¢å­—ç¬¦ä¸²ä¸­çš„å…ƒç´ ](https://leetcode-cn.com/problems/smallest-string-with-swaps)ï¼ˆä¸­ç­‰ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 947 é¢˜ï¼š[ç§»é™¤æœ€å¤šçš„åŒè¡Œæˆ–åŒåˆ—çŸ³å¤´](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column)ï¼ˆä¸­ç­‰ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 721 é¢˜ï¼š[è´¦æˆ·åˆå¹¶](https://leetcode-cn.com/problems/accounts-merge)ï¼ˆä¸­ç­‰ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 803 é¢˜ï¼š[æ‰“ç –å—](https://leetcode-cn.com/problems/bricks-falling-when-hit)ï¼ˆå›°éš¾ï¼‰ï¼›
ã€ŒåŠ›æ‰£ã€ç¬¬ 1579 é¢˜ï¼š[ä¿è¯å›¾å¯å®Œå…¨éå†](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable)ï¼ˆå›°éš¾ï¼‰;
ã€ŒåŠ›æ‰£ã€ç¬¬ 778 é¢˜ï¼š[æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³](https://leetcode-cn.com/problems/swim-in-rising-water)ï¼ˆå›°éš¾ï¼‰ã€‚

### DFS+å›æº¯

#### [37. è§£æ•°ç‹¬](https://leetcode-cn.com/problems/sudoku-solver/)

![image-20210929211741751](2.BFS_DFS_å›æº¯/image-20210929211741751.png)

```C++
//æ•°ç‹¬é¦–å…ˆè¡Œï¼Œåˆ—ï¼Œè¿˜æœ‰ 3*3 çš„æ–¹æ ¼å†…æ•°å­—æ˜¯ 1~9 ä¸èƒ½é‡å¤ã€‚
class Solution {
private:
    bool line[9][9];
    bool column[9][9];
    bool block[3][3][9];
    bool valid;
    vector<pair<int, int>> spaces;

public:
    void dfs(vector<vector<char>>& board, int pos) {
        if (pos == spaces.size()) { //é€’å½’å‡ºå£ 
            valid = true;
            return;
        }

        auto [i, j] = spaces[pos];
        for (int digit = 0; digit < 9 && !valid; ++digit) {
            if (!line[i][digit] && !column[j][digit] && !block[i / 3][j / 3][digit]) {
              	board[i][j] = digit + '0' + 1;  //x+1 è½¬æ¢ä¸ºint
                line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true; //æ ‡å¿—
                dfs(board, pos + 1);	//é€’å½’
                line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = false; //å›æº¯
            }
        }
    }

    void solveSudoku(vector<vector<char>>& board) {
        memset(line, false, sizeof(line));
        memset(column, false, sizeof(column));
        memset(block, false, sizeof(block));
        valid = false;
				
      //åˆå§‹åŒ–æ£‹ç›˜
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') {
                    spaces.emplace_back(i, j);
                }
                else {
                    int digit = board[i][j] - '0' - 1;  //x-1
                    line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true;
                }
            }
        }

        dfs(board, 0);
    }
};
```



#### [51. N çš‡å](https://leetcode-cn.com/problems/n-queens/) ğŸ€„ï¸

```C++
//T:O(n!) S:O(n)
const int N = 10; 
class Solution {
public:
    vector<vector<string>> res;
    vector<string> g;
    bool col[N],gd[N*2],rgd[N*2];//åˆ—å ç”¨ï¼Œå¯¹è§’å ç”¨ åå¯¹è§’å ç”¨ 
  //N=10,x+yæœ€å¤§ä¸º18
    void dfs(int x,int n){	 //ä»ä¸‹æ ‡ä¸ºxè¡Œå¼€å§‹æœç´¢
        if(x == n){
           res.push_back(g);	//å°†æ¯ä¸ªè§£æ”¾å…¥ç»“æœé›†ä¸­
           return;
        }
      // x+y=b æ­£å¯¹è§’çº¿ -x+y(+n)=b>=0è´Ÿå¯¹è§’çº¿
        for(int y=0;y<n;y++){ //è®¡ç®—xè¡Œçš„çš‡ååº”è¯¥æ”¾åœ¨å“ªä¸€åˆ—
            if(!col[y] && !gd[x+y] && !rgd[y-x+n]){
                g[x][y] = 'Q';
                col[y] = gd[x+y] = rgd[y-x+n] = true;//å ç”¨ä¸¤ä¸ªå¯¹è§’çº¿
                dfs(x+1,n);
                g[x][y] = '.';	//æ¢å¤ç°åœºï¼Œå›æº¯
                col[y] = gd[x+y] = rgd[y-x+n] = false;
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        for(int i = 0; i < n; i++){	//åˆå§‹åŒ–æ£‹ç›˜
            string tmp = "";
            for(int j = 0; j < n; j++) tmp += ".";
            g.push_back(tmp);
        }
        dfs(0,n);	//ä»ç¬¬0è¡Œå¼€å§‹
        return res;
    }
};
```

#### [52. Nçš‡å II](https://leetcode-cn.com/problems/n-queens-ii/)

```C++
//ä¸Šä¸€é¢˜æ”¹ä¸€æ”¹å°±å¯ä»¥äº†
//T:O(n!) S:O(n)
class Solution {
public:
    int res;
    bool col[10],gd[10*2],rgd[10*2];//åˆ—å ç”¨ï¼Œå¯¹è§’å ç”¨ åå¯¹è§’å ç”¨   
    void dfs(int x,int n){	 //ä»ä¸‹æ ‡ä¸ºxè¡Œå¼€å§‹æœç´¢
        if(x == n){
            res++;	//å°†æ¯ä¸ªè§£æ”¾å…¥ç»“æœé›†ä¸­
            return;
        }
        //b =x+y åå¯¹è§’çº¿ b=y-x (+n) >=0å¯¹è§’çº¿
        for(int y=0;y<n;y++){ //è®¡ç®—xè¡Œçš„çš‡ååº”è¯¥æ”¾åœ¨å“ªä¸€åˆ—
            if(!col[y] && !gd[y-x+n] && !rgd[x+y]){
                col[y] = gd[y-x+n] = rgd[x+y] = true;//å ç”¨ä¸¤ä¸ªå¯¹è§’çº¿
                dfs(x+1,n);
                col[y] = gd[y-x+n] = rgd[x+y] = false;//æ¢å¤ç°åœºï¼Œå›æº¯
            }
        }
    }
    int totalNQueens(int n) {
        dfs(0,n);	//ä»ç¬¬0ä¸ªä½ç½®å¼€å§‹æœç´¢
        return res;
    }
};
```



#### [93. å¤åŸ IP åœ°å€](https://leetcode-cn.com/problems/restore-ip-addresses/)

```C++
//T:O(|s|*3^SEG_COUNT) S:O(SEG_COUNT)  ,æ¯ä¸€æ®µçš„ä½æ•°ä¸ä¼šè¶…è¿‡ 3
class Solution {
private:
    static constexpr int SEG_COUNT = 4; //ipæ®µæ•°

private:
    vector<string> res;
    vector<int> segs;

public:
    void dfs(const string& s, int segId, int segStart) {
        // å¦‚æœæ‰¾åˆ°äº† 4 æ®µ IP åœ°å€å¹¶ä¸”éå†å®Œäº†å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸€ç§ç­”æ¡ˆ
        if (segId == SEG_COUNT ) {
            if( segStart == s.size()){ //(1)
                string ipAddr;
                for (int i = 0; i < SEG_COUNT; ++i) {
                ipAddr += to_string(segs[i]);
                    if (i != SEG_COUNT - 1) {   //ä¸æ˜¯æœ€åä¸€ä¸ªéƒ½åŠ '.'
                        ipAddr += ".";
                    }
                }
                res.push_back(move(ipAddr));    //move()åªæ˜¯è½¬ç§»,æé«˜åˆ©ç”¨æ•ˆç‡
            }
            return; //(2)4 æ®µ IP åœ°å€è¾¾åˆ°äº†ï¼Œä½†æ˜¯å­—ç¬¦ä¸²æ²¡æœ‰éå†å®Œï¼Œç›´æ¥å›æº¯
        }
  
        // (3)å¦‚æœè¿˜æ²¡æœ‰æ‰¾åˆ° 4 æ®µ IP åœ°å€å°±å·²ç»éå†å®Œäº†å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆæå‰å›æº¯
        if (segStart == s.size()) {
            return;
        }

        // (4)ç”±äºä¸èƒ½æœ‰å‰å¯¼é›¶ï¼Œå¦‚æœå½“å‰æ•°å­—ä¸º 0ï¼Œé‚£ä¹ˆè¿™ä¸€æ®µ IP åœ°å€åªèƒ½ä¸º 0
        if (s[segStart] == '0') {
            segs[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // ä¸€èˆ¬æƒ…å†µï¼Œæšä¸¾æ¯ä¸€ç§å¯èƒ½æ€§å¹¶é€’å½’
        int addr = 0;
        for (int segEnd = segStart; segEnd < s.size(); ++segEnd) {
            addr = addr * 10 + (s[segEnd] - '0');//è½¬åŒ–ä¸ºint
            if (addr > 0 && addr <= 0xFF) {//åœ¨0-255èŒƒå›´å†…å°±åŠ å…¥
                segs[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }

    vector<string> restoreIpAddresses(string s) {
        segs.resize(SEG_COUNT);
        dfs(s, 0, 0);
        return res;
    }
};

```

#### [79. å•è¯æœç´¢](https://leetcode-cn.com/problems/word-search/)

#### [å‰‘æŒ‡ Offer 12. çŸ©é˜µä¸­çš„è·¯å¾„](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```C++
//T: O(MNâ‹…3^L),S:O(min(L,MN))
class Solution {
public:
    int dirs[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
    bool dfs(vector<vector<char>>& board,int i,int j,string &word,int k,vector<vector<int>> &visited){
        if(board[i][j] != word[k]) return false;    //ä¸åŒ
        if(k == word.length()-1) return true;  //åŒ¹é…æˆåŠŸ

        bool res = false;
        visited[i][j] = true;               //é€‰æ‹©
        for (const auto& dir: dirs) {       //é€’å½’æœç´¢
            int x = i + dir[0], y = j + dir[1];
            if (x >= 0 && x < board.size() && y >= 0 && y < board[0].size()) {
                if (!visited[x][y]) {
                    bool flag = dfs(board, x, y, word, k + 1,visited);
                    if(flag){	//æœ‰ä¸€ä¸ªç¬¦åˆå°±è¿”å›
                        res = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;              //å›æº¯
        return res;
    }
    bool exist(vector<vector<char>>& board, string word) {
        int n = board.size();
        int m = board[0].size();
        vector<vector<int>> visited(n, vector<int>(m)); //äºŒç»´
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                int falg = dfs(board,i,j,word,0,visited);
                if(falg) return true;
            }
        }
        return false;
    }
};
```





#### [212. å•è¯æœç´¢ II](https://leetcode-cn.com/problems/word-search-ii/)

![image-20211002001203923](2.BFS_DFS_å›æº¯/image-20211002001203923.png)

```C++
//å‰ç¼€æ ‘+DFS+å›æº¯
//ç”¨å­—å…¸æ ‘å‰ªæ
//T: O(MNâ‹…3^L),S:O(kÃ—L)ï¼Œå…¶ä¸­ k æ˜¯å­—å…¸ wordsåˆ—è¡¨ çš„é•¿åº¦ï¼ŒL æ˜¯æœ€é•¿å•è¯çš„é•¿åº¦
struct TrieNode {
    string word;
    unordered_map<char,TrieNode *> children;
    TrieNode() {
        this->word = "";
    }   
};

void insertTrie(TrieNode * root,const string & word) {
    TrieNode * node = root;
    for (auto c : word){
        if (!node->children.count(c)) {	//æ²¡æœ‰ï¼ŒåŠ å…¥
            node->children[c] = new TrieNode();
        }
        node = node->children[c];//å½“å‰æŒ‡å‘child
    }
    node->word = word;
}
/*
bool searchPrefix(TrieNode* root,string prefix) {
  TrieNode* node = root;
  for (char ch : prefix) {
    if (!node->children.count(ch)) {
      return false;
    }
    node = node->children[ch];
  }
  return true;
}
*/

class Solution {
public:
    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    bool dfs(vector<vector<char>>& board, int i, int j, TrieNode * root, set<string> & res) {
        char ch = board[i][j];        
      	//å¦‚æœå½“å‰å•è¯ä¸å­˜åœ¨äºæ‰€æœ‰å•è¯çš„å‰ç¼€ä¸­ï¼Œåˆ™å¯ä»¥ç«‹å³åœæ­¢å›æº¯ã€‚å‰ªæ
        if (!root->children.count(ch)) {    //å­—å…¸wordsä¸­æ²¡æœ‰è¯¥chå‰ç¼€
            return false;
        }

        root = root->children[ch];
        if (root->word.size() > 0) {    //åŠ å…¥å½“å‰ch
            res.insert(root->word);
        }

        board[i][j] = '#';      //é€‰æ‹©(æ ‡å¿—)
        for (auto dir:dirs) {   //æœç´ 
            int x = i + dir[0],y = j + dir[1];
            if (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() && board[x][y] != '#') dfs(board, x, y, root,res);
        }
        board[i][j] = ch;   //æ’¤é”€é€‰æ‹©

        return true;      
    }

    vector<string> findWords(vector<vector<char>> & board, vector<string> & words) {
        TrieNode * root = new TrieNode();
        set<string> res;    //å»é‡
        vector<string> ans;

        //æ„é€ å­—å…¸æ ‘
        for (auto & word: words){
            insertTrie(root,word);
        }
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[0].size(); ++j) {
                dfs(board, i, j, root, res);
            }
        }        
        for (auto & word: res) {
            ans.emplace_back(word);
        }
        return ans;        
    }
};
```



### BFS

#### [934. æœ€çŸ­çš„æ¡¥](https://leetcode-cn.com/problems/shortest-bridge/) ğŸ€„ï¸

![1.jpg](2.BFS_DFS_å›æº¯/1638328692-YrAjMu-1.png)

```C++
/*å›¾BFS

*/
```

#### [126. å•è¯æ¥é¾™ II](https://leetcode-cn.com/problems/word-ladder-ii/) ğŸ€„ï¸  BFS+å›¾çš„æ„å»º

```C++
/*å›¾BFS

*/
```

#### [127. å•è¯æ¥é¾™](https://leetcode-cn.com/problems/word-ladder/)  BFS+å›¾çš„æ„å»º

```

```

#### [286.å¢™ä¸é—¨](https://leetcode-cn.com/problems/walls-and-gates/) BFS+å»é‡

```

```

#### [301. åˆ é™¤æ— æ•ˆçš„æ‹¬å·](https://leetcode-cn.com/problems/remove-invalid-parentheses/) ä¸é”™

```

```

#### [310. æœ€å°é«˜åº¦æ ‘](https://leetcode-cn.com/problems/minimum-height-trees/) ä¸é”™

```C++
/*å›¾BFS

*/
```

#### [317.ç¦»å»ºç­‘ç‰©æœ€è¿‘çš„è·ç¦»](https://leetcode-cn.com/problems/shortest-distance-from-all-buildings/) 

```C++
/*å›¾BFS

*/
```

#### [863. äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)

```C++
/*å›¾BFS

*/
```

#### [994. è…çƒ‚çš„æ©˜å­](https://leetcode-cn.com/problems/rotting-oranges/)

```C++
/*å›¾BFS

*/

```

#### [1091. äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)

```C++
/*å›¾BFS

*/

```

#### [133. å…‹éš†å›¾](https://leetcode-cn.com/problems/clone-graph/) BFS+å“ˆå¸Œ

```C++
/*å›¾DFS

*/
```

#### [261.ä»¥å›¾åˆ¤æ ‘](https://leetcode-cn.com/problems/graph-valid-tree/) BFS+å¹¶æŸ¥é›†

```C++

```

#### [323.æ— å‘å›¾ä¸­è¿é€šåˆ†é‡çš„æ•°ç›®](https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/) BFS+äºŒç»´æ•°ç»„

```

```



```C++
class Solution {
public:
    
    bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int dirs[4][2]={{0,1},{1,0},{-1,0},{0,-1}};
        int n = maze.size();
        int m = maze[0].size();
        queue<vector<int>> q;
        vector<vector<bool>> vis(n,vector<bool>(m,false));
        q.push({start[0],start[1]});
        vis[start[0]][start[1]] = true; 
        while(!q.empty()){
            auto t=q.front();
            q.pop();
            if(t[0] == destination[0] && t[1] == destination[1]) return true;
            for(auto &dir:dirs){
                int x = t[0]+dir[0],y = t[1]+dir[1];      
                while(x >=0 && x < n && y>=0 && y<m && maze[x][y] == 0){ //éå†åˆ°å¢™
                    x+=dir[0];
                    y+=dir[1];
                }
                x -= dir[0], y -= dir[1];   //æ’å¢™äº†ï¼Œå°±é€€ä¸€æ­¥
                if(!vis[x][y]){
                    q.push({x,y});
                    vis[x][y] = true;
                }
            }
        }
        return false;
    }
};
```

#### [490. è¿·å®«ğŸ€„ï¸](https://leetcode-cn.com/problems/the-maze/)

```C++
class Solution {
public:
    
    bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int dirs[4][2]={{0,1},{1,0},{-1,0},{0,-1}};
        int n = maze.size();
        int m = maze[0].size();
        queue<vector<int>> q;
        vector<vector<bool>> vis(n,vector<bool>(m,false));
        q.push({start[0],start[1]});
        vis[start[0]][start[1]] = true; 
        while(!q.empty()){
            auto t=q.front();
            q.pop();
            if(t[0] == destination[0] && t[1] == destination[1]) return true;
            for(auto &dir:dirs){
                int x = t[0]+dir[0],y = t[1]+dir[1];      
                while(x >=0 && x < n && y>=0 && y<m && maze[x][y] == 0){ //éå†åˆ°å¢™
                    x+=dir[0];
                    y+=dir[1];
                }
                x -= dir[0], y -= dir[1];   //æ’å¢™äº†ï¼Œå°±é€€ä¸€æ­¥
                if(!vis[x][y]){
                    q.push({x,y});
                    vis[x][y] = true;
                }
            }
        }
        return false;
    }
};
```

#### [505. è¿·å®« II](https://leetcode-cn.com/problems/the-maze-ii/)

```

```

#### [499. è¿·å®« III](https://leetcode-cn.com/problems/the-maze-iii/)

```

```



#### [HJ43 è¿·å®«é—®é¢˜ğŸ€„ï¸](https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc)

```C++
//T:O(m*n) 
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;

typedef pair<int, int> PII;  //pair é»˜è®¤å¯¹firstå‡åºï¼Œå½“firstç›¸åŒæ—¶å¯¹secondå‡åºï¼›
int n, m;
int dirs[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};
void bfs(vector<vector<PII>> &path,vector<vector<int>>& g)   
{
    queue<PII> q;              //ç”¨äºéå†
    q.push(make_pair(0,0));
   // d[0][0] = 0;                    //ç§»åŠ¨æ¬¡æ•°
    while (!q.empty())        //é˜Ÿåˆ—ä¸ç©º
    {
        auto t = q.front();   //å‡ºé˜Ÿ
        q.pop();
        for(auto &dir:dirs) {
            int x = t.first + dir[0], y = t.second + dir[1];
          //if(x == n-1 && y == m-1 && g[x][y] == 0) cout << "yes"<<endl; //åˆ¤æ–­æ˜¯å¦åˆ°è¾¾å‡ºå£  
          if (x >= 0 && x < n &&y >= 0 && y < m && g[x][y] == 0 ){
                //d[x][y] = d[t.first][t.second] + 1;   //ä¹‹å‰çš„è·ç¦»åŠ ä¸Šåˆèµ°çš„ä¸€æ­¥
                g[x][y] = 1;
                path[x][y] = t;        //ä»tç‚¹åˆ°(x,y)
                q.push(make_pair(x,y));   //å…¥é˜Ÿ
            }
        }
    }
    //è·¯å¾„
    vector<PII>  res;          //resç”¨äºé€†åºè¾“å‡º
    int x = n-1,y=m-1;
    res.emplace_back(make_pair(x,y));
    while(x || y){  //åŒæ—¶ä¸º0æ—¶é€€å‡º
        auto t = path[x][y];
        x = t.first,y=t.second;
        res.push_back(t);
    }
    for(int i=res.size()-1;i>=0;i--) printf("(%d,%d)\n",res[i].first,res[i].second); //(2)è·¯å¾„é€†åºè¾“å‡º
    //return d[n - 1][m - 1]; //ï¼ˆ1ï¼‰æœ€å°‘ç§»åŠ¨çš„æ¬¡æ•°
}
int main()
{
    while(cin >> n >> m){
        vector<vector<int>> g(n,vector<int>(m,0));   //gå­˜å‚¨çš„æ˜¯å›¾  då­˜å‚¨çš„æ˜¯ç§»åŠ¨æ¬¡æ•°
        //d = vector<vector<int>>(n,vector<int>(m,0));
        vector<vector<PII>> path(n*m,vector<PII>(n*m));   //preä¿å­˜ç‚¹æ˜ å°„ç‚¹ æ³¨æ„è¿™é‡Œéœ€è¦n*m
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++)
                cin>>g[i][j];    //å­˜å…¥åœ°å›¾
        }
        bfs(path,g);
    }
    return 0;
}
```

#### [1926. è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£ğŸ€„ï¸](https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze/)

```C++
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int dirs[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
        int n = maze.size();
        int m = maze[0].size();
        queue<tuple<int, int, int>> q;           //(x,y,d)   dæ˜¯ç›¸å¯¹å…¥å£çš„è·ç¦»
        q.emplace(entrance[0],entrance[1],0);
        maze[entrance[0]][entrance[1]] = '+';   //éå†è¿‡äº†ï¼Œé˜²æ­¢é‡å¤è®¿é—®
        while(!q.empty()){
            auto [mx,my,d] = q.front();
            q.pop();
            for(auto &dir:dirs){
                int x=mx+dir[0],y=my+dir[1];
                if(x >=0 && x <n && y>=0 && y <m && maze[x][y] == '.'){ //è¾¹ç•Œæ—¶è¿”å›ç­”æ¡ˆ
                    if(x == 0 || x == n-1 || y== 0 || y == m -1 ) return d+1;
                    maze[x][y] = '+';
                    q.emplace(x,y,d+1);
                }
            }
        }
        return -1;
    }
};
```



#### [PDD4è¿·å®«å¯»è·¯](https://www.nowcoder.com/practice/e3fc4f8094964a589735d640424b6a47?tpId=182&gioEnter=menu)

```C++
//ACä»£ç :
#include<stdio.h>
#include<queue>
#include<string.h>
#include<vector>
using namespace std;
char G[105][105];
int book[105][105][1200],N,M;
int Next[4][2]={0,1,0,-1,1,0,-1,0};
int bfs(int,int);
struct node{
    int x,y,k,step;
    node(int x,int y,int k,int step):x(x),y(y),k(k),step(step){}
};
int main(){
    int i,j;
    //freopen("input.txt","r",stdin);
    while(scanf("%d%d",&N,&M)!=EOF){
        for(i=0;i<N;i++) scanf("%s",G[i]);
        memset(book,0,sizeof(book));
        int flag=0;
        for(i=0;i<N;i++){
            if(flag==1) break;
            for(j=0;j<M;j++)
                if(G[i][j]=='2'){
                    flag=1;
                    book[i][j][0]=1;
                    printf("%d\n",bfs(i,j));
                    break;
                }
        }
    }
}
int bfs(int startX,int startY){
    queue<node> Q;
    Q.push(node(startX,startY,0,0));
    while(!Q.empty()){
        node head=Q.front();Q.pop();
        if(G[head.x][head.y]=='3') return head.step;
        for(int i=0;i<4;i++){
            int nx=head.x+Next[i][0],ny=head.y+Next[i][1];
            if(nx>=N||nx<0||ny>=M||ny<0||G[nx][ny]=='0') continue;
            int key=head.k;
            if('a'<=G[nx][ny]&&G[nx][ny]<='z') key=key|(1<<(G[nx][ny]-'a'));
            if('A'<=G[nx][ny]&&G[nx][ny]<='Z'&&(key&(1<<(G[nx][ny]-'A')))==0) continue;	//æ²¡æœ‰è¯¥é’¥åŒ™
            if(!book[nx][ny][key]){
                book[nx][ny][key]=1;
                Q.push(node(nx,ny,key,head.step+1));
            }
        }
    }
    return 0;
}//è¿™é¢˜å°±æ˜¯æ™®é€šçš„bfså¤šäº†â€˜é’¥åŒ™â€™è¿™ä¸ªçŠ¶æ€ 
 //æ‰€ä»¥book[x][y][key]çš„æ„ä¹‰å°±æ˜¯ æ¨ªåæ ‡ä¸ºx,çºµåæ ‡ä¸ºy,é’¥åŒ™çŠ¶æ€ä¸ºkeyçš„ç‚¹æ˜¯å¦è®¿é—®è¿‡ 
 //é’¥åŒ™çš„çŠ¶æ€ å°±ç”¨äºŒè¿›åˆ¶æ•°è¡¨ç¤º æœ€å¤š10 æŠŠé’¥åŒ™ é‚£å°±æ˜¯1024
 //æ¯”å¦‚æˆ‘ç°åœ¨æœ‰ç¬¬äºŒæŠŠé’¥åŒ™å’Œç¬¬å››æŠŠé’¥åŒ™  é‚£ä¹ˆæˆ‘çš„é’¥åŒ™çŠ¶æ€å°±æ˜¯ 0101000000 ä¹Ÿå°±æ˜¯ 320
```

#### [æœºå™¨äººèµ°è¿·å®«](https://www.nowcoder.com/discuss/596162?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=7CDE02A66517EFFDE8544F0962A4C635-1639577561411)

```

```

#### [èµ°è¿·å®«æœ€å°æ¶ˆè€—](https://leetcode-cn.com/circle/discuss/cg0ayO/)

```

```

#### [1036. é€ƒç¦»å¤§è¿·å®«](https://leetcode-cn.com/problems/escape-a-large-maze/)

```

```



