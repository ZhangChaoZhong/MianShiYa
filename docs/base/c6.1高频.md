![在这里插入图片描述](images/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5YWc5YWc5pyJ57OWYA==,size_20,color_FFFFFF,t_70,g_se,x_16.png)

### **SpringMVC** **工作流程** ⭐️

1）用户发送请求至**前端控制器 DispatcherServlet**。 

2）DispatcherServlet 收到请求**调用 HandlerMapping 处理器映射器**。

> 维护<url，handler>的映射

3）处理器映射器找到**具体的处理器**(可以根据 **xml 配置、注解**进行查找)，**生成处理器Handler及处理器拦截器** (如果有则生成)一并**返回给 DispatcherServlet**。 

4）DispatcherServlet **调用 HandlerAdapter 处理器适配器执行Handler**。 

> 适配器模式：HandlerAdapter会根据handler规则执行不同类型的handler

5）HandlerAdapter **经过适配执行具体的handler**(Controller，也叫**后端控制器**) 

6） handler执行完成**返回 ModelAndView**。 

7）HandlerAdapter 将 handler 执行结果 **ModelAndView 返回给 DispatcherServlet**。

8） DispatcherServlet 将 ModelAndView 传给 **ViewReslover 视图解析器**。 

9）ViewReslover **解析后返回具体 View**。 

10）DispatcherServlet 根据 View **进行视图渲染**（即将模型数据填充至视图中）。 

11）DispatcherServlet **响应用户**。

![springmvc工作流程图](images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ4ODM1NQ==,size_16,color_FFFFFF,t_70.jpeg)

### 

### 描述一下Spring Bean的生命周期？⭐️

1、（扫描路径，找到类）**解析类**得到BeanDefinition 

2、如果有多个构造方法，则要**推断构造方法** 

3、确定好构造方法后，进行**实例化**得到一个Bean对象 

4、对对象中的加了@Autowired注解的属性**进行属性填充** 

5、**回调Aware方法**，比如BeanNameAware，BeanFactoryAware

6、调用**BeanPostProcessor的初始化前**的方法 

7、调用**初始化**方法 

8、调用**BeanPostProcessor的初始化后**的方法，在这里会进行**AOP** 

9、**如果**当前创建的**bean是单例**的则会把bean放入**单例池** 

10、使用bean （运行期）

11、Spring容器关闭时调用DisposableBean中destory()方法 

### 谈谈你对IOC的理解⭐️

容器概念、控制反转、依赖注入

**ioc容器**：实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、 @repository、@service、@controller、@component），在项目启动的时候会**读取配置文件**里面的 bean节点，**根据全限定类名使用反射**创建对象放到map里、**扫描到打上上述注解**的类还是通过反射创建对象放到map里。 

这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再**通过DI注入**（autowired、resource等注解或xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性 。根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。 

**控制反转：** 

没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，**自己必须主动去创建对象B**或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 

引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，**IOC容器会主动创建一个对象B注入到对象A需要的地方**。 

通过前后的对比，不难看出来：对象A获得依赖对象B的过程**,由主动行为变为了被动行为**，控制权颠倒过来了，**这就是“控制反转”这个名称的由来**。 

全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种**类似“粘合剂”的作用**，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。 

**依赖注入：** 

“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程**由自身管理变为了由IOC容器主动注入**。**依赖注入是实现IOC的方法**：就是由IOC容器在运行期间，**动态地**将某种依赖关系**注入**到对象之中。 

### AOP

当我们需要**为分散的对象引入公共行为**的时候，OOP则显得无能为力。也就是说，**OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系**。例如日志功能。 

日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。 在OOP设计中，它导致了大量代码的重复，而**不利于各个模块的重用**。 

AOP：将程序中的交叉业务逻辑（比如**安全，日志，事务**等），封**装成一个切面，然后注入到目标对象（具体业务逻辑）**中去。AOP可以对某个对象或某些对象的功能**进行增强**，比如对象中的方法进行增强，可以在执行某个方法之前或者之后额外的做一些事情。

项目中：主要使用的 AOP去做权限认证，还有一些日志的操作，因为是将它可以定义一些切点，然后将那个切点的一些切面动态植入进去，很方便地去帮我们做一些权限的判断。比如说我们用 jwt 然后进我们的系统之前可以先 AOP 拦截下来，然后去判断他这个权限，然后也可以去把我们的一些日志操作。

然后 AOP实现方式有2种（基于xml；基于注解）

Spring AOP有2种代理模式

第一个就是 JDK 的 proxy，利用java中的反射技术实现的。
基于动态jdk涉及到**两个核心的类Proxy类和一个 InvocationHandler接口。**通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

**第二个就是CGLIB一个基于[ASM](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在**运行时对字节码进行修改和动态生成**。**CGLIB 通过继承方式实现代理**。例如 Spring 中的 AOP 模块中：如果目标**对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。

**在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。**你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。

区别：

（1）**JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。**

（2）由于是通过“子类化”的方式， 所以不能代理声明为 final 类型的类和方法

（3）就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

> cglib3.1 JDK8 在运行次数较少（1,000,000）的情况下，jdk动态代理比 cglib 快了差不多30%；而当调用次数增加之后(50,000,000)， 动态代理比 cglib 快了接近1倍。

另外：不同于 JDK 动态代理不需要额外的依赖。[CGLIB](https://github.com/cglib/cglib)(*Code Generation Library*) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。

### 索引优化

索引是mysql调优比较大的过程。

（1）首先，创建索引，考虑以下几个因素

- **索引覆盖**，可以无需回表
- mysql5.6+，对索引覆盖也做了优化，支持**索引下推**的功能，数据筛选由MySQL服务器(内存)向下传递至存储引擎（磁盘），减少IO(回表)次数。这个我们在explain执行计划，看extra里面的字段using index condition，其实我们可以进一步地对它优化

- 因为我们都知道机械硬盘它是那个那个很怕随机读写的，它有一个磁盘寻址的开销。然后可以开启MMR， multi range read 它可以再回表之前把我们的 ID 读到一个 buffer 里面，进行一个排序，把原来的随机磁盘读变成一个顺序磁盘读，从而提高了索引查询的性能。

> 我觉得这是索引覆盖可以做的一些优化，因为索引覆盖也可以避免比如说排序用到临时文件，或者可以配合最左原则，然后减少一些索引的维护，这一块是可以做的。

（2）然后，还有一块如果对一些普通索引，如果我们是一个**写多读少**的服务，，并且这个服务**唯一性要求没有那么高**，或者我们的业务代码可以保证唯一性的时候，我们可以用普通索引，因为普通索引是可以用到 **change buffer** 的，然后change buffer就可以把一些写操作给缓存下来，然后在我们**读的时候进行一个merge的操作**，这样话就可以提高我们的写入的速度，还有我们内存的一个命中率。这个我认为在创建索引的时候也可以考虑的一些点。

> 反过来，写少读多的服务：假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。

（3）然后还有一些点如果我这个索引走不上，我们应该考虑哪些方面？如果这个索引走不上的话，可以考虑2方面
第一： 是不是我们的 sql 写得有问题，比如说我们对索引字段进行了**一些函数操作**，或者在连接查询的时候，两个表的编码不一样；要不然我们可以再进一步的排查，有没有可能他两个的那个**字段的类型不一样**，比如说 string 然后赋给他的一个 ID， 因为我们如果String和 ID 比较的话，我们会把String转成 ID ，在 Mysql 里面，然后运用到了一个隐式的 CAST 的函数转换
第二：可以考虑是不是**索引统计信息是否有问题**。如果索引统计信息有问题的话，我们可以去 Analyze table 重新统计所有信息。因为我们知道这个索引信息并不是一个准确的值，它是一个随机采样的过程，然后可能会出现问题；还有我们的表因为是业务表可能分太多，内存的空洞也比较多，所以都有可能造成索引的一个选择的问题。

 explain 分析出来的，所以它一定是最优的吗？是不一定的，因为她可能会选错。因为我们在索引的时候可能会涉及到回表操作，还有一些排序操作，然后他很可能会走错。

比如说索引建的不好，然后导致索引就走得很差吗？查询速度慢的那种情况。
我觉得如果碰到这种情况的话，首先我们可以考虑用那个 **force index** 然后强制走一个。所以但这个是不太好的，是作为一个业务的应急预案。然后因为他可能迁到别的一个数据库里面就不支持了。然后他还需要我们做**一个代码的重新的一个发布**，然后这个是不太好的。然后还有一种我们可以考虑**用索引覆盖加最左原则**，考虑能不能把这个选错了索引给删掉，这样的话其实还也是一个优化的方案之一。我觉得而且其实挺常用的。

### 查询优化

